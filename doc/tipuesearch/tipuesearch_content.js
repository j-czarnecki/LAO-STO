var tipuesearch = {"pages":[{"title":" Fortran Program ","text":"Fortran Program LAO-STO project: LAO-STO\nauthor: jczarnecki","tags":"home","loc":"index.html"},{"title":"COMPUTE_TBA_TERM – Fortran Program","text":"public  subroutine COMPUTE_TBA_TERM(Hamiltonian, kx, ky) Arguments Type Intent Optional Attributes Name complex(kind=16), intent(inout) :: Hamiltonian (DIM,DIM) real(kind=8), intent(inout) :: kx real(kind=8), intent(inout) :: ky","tags":"","loc":"proc/compute_tba_term.html"},{"title":"COMPUTE_ATOMIC_SOC_TERMS – Fortran Program","text":"public  subroutine COMPUTE_ATOMIC_SOC_TERMS(Hamiltonian) Arguments Type Intent Optional Attributes Name complex(kind=16), intent(inout) :: Hamiltonian (DIM,DIM)","tags":"","loc":"proc/compute_atomic_soc_terms.html"},{"title":"COMPUTE_TRIGONAL_TERMS – Fortran Program","text":"public  subroutine COMPUTE_TRIGONAL_TERMS(Hamiltonian) Arguments Type Intent Optional Attributes Name complex(kind=16), intent(inout) :: Hamiltonian (DIM,DIM)","tags":"","loc":"proc/compute_trigonal_terms.html"},{"title":"COMPUTE_ELECTRIC_FIELD – Fortran Program","text":"public  subroutine COMPUTE_ELECTRIC_FIELD(Hamiltonian) Arguments Type Intent Optional Attributes Name complex(kind=16), intent(inout) :: Hamiltonian (DIM,DIM)","tags":"","loc":"proc/compute_electric_field.html"},{"title":"COMPUTE_TI1_TI2 – Fortran Program","text":"public  subroutine COMPUTE_TI1_TI2(Hamiltonian, kx, ky) Arguments Type Intent Optional Attributes Name complex(kind=16), intent(inout) :: Hamiltonian (DIM,DIM) real(kind=8), intent(inout) :: kx real(kind=8), intent(inout) :: ky","tags":"","loc":"proc/compute_ti1_ti2.html"},{"title":"COMPUTE_H_PI – Fortran Program","text":"public  subroutine COMPUTE_H_PI(Hamiltonian, kx, ky) Arguments Type Intent Optional Attributes Name complex(kind=16), intent(inout) :: Hamiltonian (DIM,DIM) real(kind=8), intent(inout) :: kx real(kind=8), intent(inout) :: ky","tags":"","loc":"proc/compute_h_pi.html"},{"title":"COMPUTE_H_SIGMA – Fortran Program","text":"public  subroutine COMPUTE_H_SIGMA(Hamiltonian, kx, ky) Arguments Type Intent Optional Attributes Name complex(kind=16), intent(inout) :: Hamiltonian (DIM,DIM) real(kind=8), intent(inout) :: kx real(kind=8), intent(inout) :: ky","tags":"","loc":"proc/compute_h_sigma.html"},{"title":"COMPUTE_SC – Fortran Program","text":"public  subroutine COMPUTE_SC(Hamiltonian, kx, ky, Gamma_SC) Arguments Type Intent Optional Attributes Name complex(kind=16), intent(inout) :: Hamiltonian (DIM,DIM) real(kind=8), intent(in) :: kx real(kind=8), intent(in) :: ky complex(kind=16), intent(in) :: Gamma_SC (ORBITALS,N_ALL_NEIGHBOURS,2,SUBLATTICES)","tags":"","loc":"proc/compute_sc.html"},{"title":"COMPUTE_HUBBARD – Fortran Program","text":"public  subroutine COMPUTE_HUBBARD(Hamiltonian, Charge_dens) Arguments Type Intent Optional Attributes Name complex(kind=16), intent(inout) :: Hamiltonian (DIM,DIM) real(kind=8), intent(in) :: Charge_dens (DIM_POSITIVE_K)","tags":"","loc":"proc/compute_hubbard.html"},{"title":"COMPUTE_ZEEMAN – Fortran Program","text":"public  subroutine COMPUTE_ZEEMAN(Bfield, Hamiltonian) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: Bfield (3) complex(kind=16), intent(inout) :: Hamiltonian (DIM,DIM)","tags":"","loc":"proc/compute_zeeman.html"},{"title":"DIAGONAL_TBA – Fortran Program","text":"public  subroutine DIAGONAL_TBA(Hamiltonian, kx, ky) Arguments Type Intent Optional Attributes Name complex(kind=16), intent(inout) :: Hamiltonian (DIM,DIM) real(kind=8), intent(inout) :: kx real(kind=8), intent(inout) :: ky","tags":"","loc":"proc/diagonal_tba.html"},{"title":"GET_INPUT – Fortran Program","text":"public  subroutine GET_INPUT(nmlfile) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: nmlfile","tags":"","loc":"proc/get_input.html"},{"title":"GET_GAMMA_SC – Fortran Program","text":"public  subroutine GET_GAMMA_SC(Gamma_SC, path) Arguments Type Intent Optional Attributes Name complex(kind=16), intent(out) :: Gamma_SC (ORBITALS,N_ALL_NEIGHBOURS,2,SUBLATTICES) character(len=*), intent(in) :: path","tags":"","loc":"proc/get_gamma_sc.html"},{"title":"GET_CHARGE_DENS – Fortran Program","text":"public  subroutine GET_CHARGE_DENS(Charge_dens, path) Arguments Type Intent Optional Attributes Name real(kind=8), intent(out) :: Charge_dens (DIM_POSITIVE_K) character(len=*), intent(in) :: path","tags":"","loc":"proc/get_charge_dens.html"},{"title":"GET_LOCAL_CHARGE_AND_DELTA – Fortran Program","text":"public  subroutine GET_LOCAL_CHARGE_AND_DELTA(Hamiltonian_const, Gamma_SC, Charge_dens, k1, k2, Delta_local, Charge_dens_local) Arguments Type Intent Optional Attributes Name complex(kind=16), intent(in) :: Hamiltonian_const (DIM,DIM) complex(kind=16), intent(in) :: Gamma_SC (ORBITALS,N_ALL_NEIGHBOURS,2,SUBLATTICES) real(kind=8), intent(in) :: Charge_dens (DIM_POSITIVE_K) real(kind=8), intent(in) :: k1 real(kind=8), intent(in) :: k2 complex(kind=16), intent(out) :: Delta_local (ORBITALS,N_ALL_NEIGHBOURS,2,SUBLATTICES) real(kind=8), intent(out) :: Charge_dens_local (DIM_POSITIVE_K)","tags":"","loc":"proc/get_local_charge_and_delta.html"},{"title":"ROMBERG_Y – Fortran Program","text":"public  subroutine ROMBERG_Y(Hamiltonian_const, Gamma_SC, Charge_dens, k1_chunk_min, k1_chunk_max, k2_chunk_min, k2_chunk_max, Delta_local, Charge_dens_local, romb_eps_x, interpolation_deg_x, max_grid_refinements_x, romb_eps_y, interpolation_deg_y, max_grid_refinements_y) !!!!!! THIS PART COULD LEAD TO A PROBLEM !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Arguments Type Intent Optional Attributes Name complex(kind=16), intent(in) :: Hamiltonian_const (DIM,DIM) complex(kind=16), intent(in) :: Gamma_SC (ORBITALS,N_ALL_NEIGHBOURS,2,SUBLATTICES) real(kind=8), intent(in) :: Charge_dens (DIM_POSITIVE_K) real(kind=8), intent(in) :: k1_chunk_min real(kind=8), intent(in) :: k1_chunk_max real(kind=8), intent(in) :: k2_chunk_min real(kind=8), intent(in) :: k2_chunk_max complex(kind=16), intent(out) :: Delta_local (ORBITALS,N_ALL_NEIGHBOURS,2,SUBLATTICES) real(kind=8), intent(out) :: Charge_dens_local (DIM_POSITIVE_K) real(kind=8), intent(in) :: romb_eps_x integer(kind=4), intent(in) :: interpolation_deg_x integer(kind=4), intent(in) :: max_grid_refinements_x real(kind=8), intent(in) :: romb_eps_y integer(kind=4), intent(in) :: interpolation_deg_y integer(kind=4), intent(in) :: max_grid_refinements_y","tags":"","loc":"proc/romberg_y.html"},{"title":"ROMBERG_X – Fortran Program","text":"public  subroutine ROMBERG_X(Hamiltonian_const, Gamma_SC, Charge_dens, k1_chunk_min, k1_chunk_max, k2_actual, Delta_local, Charge_dens_local, romb_eps_x, interpolation_deg_x, max_grid_refinements_x) !!!!!! THIS PART COULD LEAD TO A PROBLEM !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Arguments Type Intent Optional Attributes Name complex(kind=16), intent(in) :: Hamiltonian_const (DIM,DIM) complex(kind=16), intent(in) :: Gamma_SC (ORBITALS,N_ALL_NEIGHBOURS,2,SUBLATTICES) real(kind=8), intent(in) :: Charge_dens (DIM_POSITIVE_K) real(kind=8), intent(in) :: k1_chunk_min real(kind=8), intent(in) :: k1_chunk_max real(kind=8), intent(in) :: k2_actual complex(kind=16), intent(out) :: Delta_local (ORBITALS,N_ALL_NEIGHBOURS,2,SUBLATTICES) real(kind=8), intent(out) :: Charge_dens_local (DIM_POSITIVE_K) real(kind=8), intent(in) :: romb_eps_x integer(kind=4), intent(in) :: interpolation_deg_x integer(kind=4), intent(in) :: max_grid_refinements_x","tags":"","loc":"proc/romberg_x.html"},{"title":"POLINT – Fortran Program","text":"public  subroutine POLINT(X, Y, deg, x_target, y_approx, dy) Arguments Type Intent Optional Attributes Name complex(kind=16), intent(in) :: X (deg) complex(kind=16), intent(in) :: Y (deg) integer(kind=4), intent(in) :: deg complex(kind=16), intent(in) :: x_target complex(kind=16), intent(out) :: y_approx complex(kind=16), intent(out) :: dy","tags":"","loc":"proc/polint.html"},{"title":"mix_broyden – Fortran Program","text":"public  subroutine mix_broyden(ndim, deltaout, deltain, alphamix, iter, n_iter, conv) Modified Broyden's method for potential/charge density mixing\n            D.D.Johnson, PRB 38, 12807 (1988) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ndim Dimension of arrays deltaout, deltain real(kind=8), intent(inout) :: deltaout (ndim) output Delta at current iteration real(kind=8), intent(inout) :: deltain (ndim) Delta at previous iteration real(kind=8), intent(in) :: alphamix Mixing factor (0 < alphamix <= 1) integer, intent(in) :: iter Current iteration number integer, intent(in) :: n_iter Number of iterations used in the mixing logical, intent(in) :: conv If true convergence reache","tags":"","loc":"proc/mix_broyden.html"},{"title":"epsilon_yz – Fortran Program","text":"public pure function epsilon_yz(kx, ky) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: kx real(kind=8), intent(in) :: ky Return Value complex(kind=16)","tags":"","loc":"proc/epsilon_yz.html"},{"title":"epsilon_zx – Fortran Program","text":"public pure function epsilon_zx(kx, ky) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: kx real(kind=8), intent(in) :: ky Return Value complex(kind=16)","tags":"","loc":"proc/epsilon_zx.html"},{"title":"epsilon_xy – Fortran Program","text":"public pure function epsilon_xy(kx, ky) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: kx real(kind=8), intent(in) :: ky Return Value complex(kind=16)","tags":"","loc":"proc/epsilon_xy.html"},{"title":"pairing_1 – Fortran Program","text":"public pure function pairing_1(ky) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: ky Return Value complex(kind=16)","tags":"","loc":"proc/pairing_1.html"},{"title":"pairing_2 – Fortran Program","text":"public pure function pairing_2(kx, ky) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: kx real(kind=8), intent(in) :: ky Return Value complex(kind=16)","tags":"","loc":"proc/pairing_2.html"},{"title":"pairing_3 – Fortran Program","text":"public pure function pairing_3(kx, ky) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: kx real(kind=8), intent(in) :: ky Return Value complex(kind=16)","tags":"","loc":"proc/pairing_3.html"},{"title":"pairing_nnn_1 – Fortran Program","text":"public pure function pairing_nnn_1(kx) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: kx Return Value complex(kind=16)","tags":"","loc":"proc/pairing_nnn_1.html"},{"title":"pairing_nnn_2 – Fortran Program","text":"public pure function pairing_nnn_2(kx, ky) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: kx real(kind=8), intent(in) :: ky Return Value complex(kind=16)","tags":"","loc":"proc/pairing_nnn_2.html"},{"title":"pairing_nnn_3 – Fortran Program","text":"public pure function pairing_nnn_3(kx, ky) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: kx real(kind=8), intent(in) :: ky Return Value complex(kind=16)","tags":"","loc":"proc/pairing_nnn_3.html"},{"title":"pairing_nnn_4 – Fortran Program","text":"public pure function pairing_nnn_4(kx) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: kx Return Value complex(kind=16)","tags":"","loc":"proc/pairing_nnn_4.html"},{"title":"pairing_nnn_5 – Fortran Program","text":"public pure function pairing_nnn_5(kx, ky) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: kx real(kind=8), intent(in) :: ky Return Value complex(kind=16)","tags":"","loc":"proc/pairing_nnn_5.html"},{"title":"pairing_nnn_6 – Fortran Program","text":"public pure function pairing_nnn_6(kx, ky) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: kx real(kind=8), intent(in) :: ky Return Value complex(kind=16)","tags":"","loc":"proc/pairing_nnn_6.html"},{"title":"fd_distribution – Fortran Program","text":"public pure function fd_distribution(E, E_Fermi, T) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: E real(kind=8), intent(in) :: E_Fermi real(kind=8), intent(in) :: T Return Value real(kind=8)","tags":"","loc":"proc/fd_distribution.html"},{"title":"dirac_delta – Fortran Program","text":"public  function dirac_delta(E, omega, zeta) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: E real(kind=8), intent(in) :: omega real(kind=8), intent(in) :: zeta Return Value real(kind=8)","tags":"","loc":"proc/dirac_delta.html"},{"title":"meV_to_au – Fortran Program","text":"public  function meV_to_au(x) Arguments Type Intent Optional Attributes Name real(kind=8) :: x Return Value real(kind=8)","tags":"","loc":"proc/mev_to_au.html"},{"title":"nm_to_au – Fortran Program","text":"public  function nm_to_au(x) Arguments Type Intent Optional Attributes Name real(kind=8) :: x Return Value real(kind=8)","tags":"","loc":"proc/nm_to_au.html"},{"title":"au_to_meV – Fortran Program","text":"public  function au_to_meV(x) Arguments Type Intent Optional Attributes Name real(kind=8) :: x Return Value real(kind=8)","tags":"","loc":"proc/au_to_mev.html"},{"title":"au_to_nm – Fortran Program","text":"public  function au_to_nm(x) Arguments Type Intent Optional Attributes Name real(kind=8) :: x Return Value real(kind=8)","tags":"","loc":"proc/au_to_nm.html"},{"title":"DIAGONALIZE_HERMITIAN – Fortran Program","text":"public  subroutine DIAGONALIZE_HERMITIAN(Hamiltonian, Eigenvalues, N) Arguments Type Intent Optional Attributes Name complex(kind=16), intent(inout) :: Hamiltonian (N,N) real(kind=8), intent(out) :: Eigenvalues (N) integer(kind=4), intent(in) :: N","tags":"","loc":"proc/diagonalize_hermitian.html"},{"title":"DIAGONALIZE_GENERALIZED – Fortran Program","text":"public  subroutine DIAGONALIZE_GENERALIZED(Hamiltonian, Eigenvalues, U_transformation, N) Arguments Type Intent Optional Attributes Name complex(kind=16), intent(inout) :: Hamiltonian (N,N) real(kind=8), intent(out) :: Eigenvalues (N) complex(kind=16), intent(inout) :: U_transformation (N,N) integer(kind=4), intent(in) :: N","tags":"","loc":"proc/diagonalize_generalized.html"},{"title":"COMPUTE_CONJUGATE_ELEMENTS – Fortran Program","text":"public  subroutine COMPUTE_CONJUGATE_ELEMENTS(Hamiltonian, N) Arguments Type Intent Optional Attributes Name complex(kind=16), intent(inout) :: Hamiltonian (N,N) integer(kind=4), intent(in) :: N","tags":"","loc":"proc/compute_conjugate_elements.html"},{"title":"PRINT_HAMILTONIAN – Fortran Program","text":"public  subroutine PRINT_HAMILTONIAN(Hamiltonian) Arguments Type Intent Optional Attributes Name complex(kind=16), intent(in) :: Hamiltonian (DIM,DIM)","tags":"","loc":"proc/print_hamiltonian.html"},{"title":"PRINT_ENERGIES – Fortran Program","text":"public  subroutine PRINT_ENERGIES(Energies, k1_steps, k2_steps, dk1, dk2, filename, N) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: Energies (0:k1_steps,0:k2_steps,N) integer(kind=4), intent(in) :: k1_steps integer(kind=4), intent(in) :: k2_steps real(kind=8), intent(in) :: dk1 real(kind=8), intent(in) :: dk2 character(len=*), intent(in) :: filename integer(kind=4), intent(in) :: N","tags":"","loc":"proc/print_energies.html"},{"title":"PRINT_GAMMA – Fortran Program","text":"public  subroutine PRINT_GAMMA(Gamma_SC, filename) Arguments Type Intent Optional Attributes Name complex(kind=16), intent(in) :: Gamma_SC (ORBITALS,N_ALL_NEIGHBOURS,2,SUBLATTICES) character(len=*), intent(in) :: filename","tags":"","loc":"proc/print_gamma.html"},{"title":"PRINT_CHARGE – Fortran Program","text":"public  subroutine PRINT_CHARGE(Charge_dens, filename) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: Charge_dens (DIM_POSITIVE_K) character(len=*), intent(in) :: filename","tags":"","loc":"proc/print_charge.html"},{"title":"det – Fortran Program","text":"public  function det(matrix, n) Arguments Type Intent Optional Attributes Name complex(kind=16), intent(in) :: matrix (n,n) integer(kind=4), intent(in) :: n Return Value complex(kind=16)","tags":"","loc":"proc/det.html"},{"title":"CALCULATE_DOS – Fortran Program","text":"public  subroutine CALCULATE_DOS(E_DOS_min, E_DOS_max, dE0, zeta_DOS, DOS_filename) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: E_DOS_min real(kind=8), intent(in) :: E_DOS_max real(kind=8), intent(in) :: dE0 real(kind=8), intent(in) :: zeta_DOS character(len=*), intent(in) :: DOS_filename","tags":"","loc":"proc/calculate_dos.html"},{"title":"CALCULATE_DISPERSION – Fortran Program","text":"public  subroutine CALCULATE_DISPERSION(filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename","tags":"","loc":"proc/calculate_dispersion.html"},{"title":"CALCULATE_CHERN_PARAMS – Fortran Program","text":"public  subroutine CALCULATE_CHERN_PARAMS(Nk1, Nk2, HamDim) Calculates Chern Params, based on https://arxiv.org/abs/cond-mat/0503172 Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in) :: Nk1 Number of divisions along k1 integer(kind=4), intent(in) :: Nk2 Number of divisions along k2 integer(kind=4), intent(in) :: HamDim DImension of the hamiltonian to be diagonalized (e.g. 4 for simple hellical, 24 for LAO-STO)","tags":"","loc":"proc/calculate_chern_params.html"},{"title":"HELLICAL_TEST_CHERN – Fortran Program","text":"public  subroutine HELLICAL_TEST_CHERN(potChem, B, Nk1, Nk2, i, j, U_transformation) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: potChem real(kind=8), intent(in) :: B (3) integer(kind=4), intent(in) :: Nk1 integer(kind=4), intent(in) :: Nk2 integer(kind=4), intent(in) :: i integer(kind=4), intent(in) :: j complex(kind=16), intent(inout) :: U_transformation (HamDim,HamDim)","tags":"","loc":"proc/hellical_test_chern.html"},{"title":"LAO_STO_CHERN_ENERGIES – Fortran Program","text":"public  subroutine LAO_STO_CHERN_ENERGIES(Nk1, Nk2, i, j, run_dir, U_transformation) This subroutine calculates energies and wavefunctions of LAO-STO in [111] direction.\nReturns sorted wavefunctions in (i,j) point of the Brillouin zone. Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in) :: Nk1 Number of divisions of Brillouin zone in direction k1. integer(kind=4), intent(in) :: Nk2 Number of divisions of Brillouin zone in direction k2. integer(kind=4), intent(in) :: i Curent point k1_i in the Brillouin zone integer(kind=4), intent(in) :: j Curent point k2_j in the Brillouin zone character(len=*), intent(in) :: run_dir Directory of the run, where input.nml should be placed.\nIt contains material information and physical parameter of calculation:\nFermi energy, temperature etc. complex(kind=16), intent(out) :: U_transformation (DIM,DIM) Matrix containing eigenvectors stored in consecutive columns.\nOn output sorted based on energies from lowest to highest.","tags":"","loc":"proc/lao_sto_chern_energies.html"},{"title":"SORT_ENERGIES_AND_WAVEFUNCTIONS – Fortran Program","text":"public  subroutine SORT_ENERGIES_AND_WAVEFUNCTIONS(Energies, Psi, HamDim) Arguments Type Intent Optional Attributes Name real(kind=8), intent(inout) :: Energies (HamDim) complex(kind=16), intent(inout) :: Psi (HamDim,HamDim) integer(kind=4), intent(in) :: HamDim","tags":"","loc":"proc/sort_energies_and_wavefunctions.html"},{"title":"mod_hamiltonians – Fortran Program","text":"Uses mod_reader mod_utilities mod_parameters Subroutines public  subroutine COMPUTE_TBA_TERM (Hamiltonian, kx, ky) Arguments Type Intent Optional Attributes Name complex(kind=16), intent(inout) :: Hamiltonian (DIM,DIM) real(kind=8), intent(inout) :: kx real(kind=8), intent(inout) :: ky public  subroutine COMPUTE_ATOMIC_SOC_TERMS (Hamiltonian) Arguments Type Intent Optional Attributes Name complex(kind=16), intent(inout) :: Hamiltonian (DIM,DIM) public  subroutine COMPUTE_TRIGONAL_TERMS (Hamiltonian) Arguments Type Intent Optional Attributes Name complex(kind=16), intent(inout) :: Hamiltonian (DIM,DIM) public  subroutine COMPUTE_ELECTRIC_FIELD (Hamiltonian) Arguments Type Intent Optional Attributes Name complex(kind=16), intent(inout) :: Hamiltonian (DIM,DIM) public  subroutine COMPUTE_TI1_TI2 (Hamiltonian, kx, ky) Arguments Type Intent Optional Attributes Name complex(kind=16), intent(inout) :: Hamiltonian (DIM,DIM) real(kind=8), intent(inout) :: kx real(kind=8), intent(inout) :: ky public  subroutine COMPUTE_H_PI (Hamiltonian, kx, ky) Arguments Type Intent Optional Attributes Name complex(kind=16), intent(inout) :: Hamiltonian (DIM,DIM) real(kind=8), intent(inout) :: kx real(kind=8), intent(inout) :: ky public  subroutine COMPUTE_H_SIGMA (Hamiltonian, kx, ky) Arguments Type Intent Optional Attributes Name complex(kind=16), intent(inout) :: Hamiltonian (DIM,DIM) real(kind=8), intent(inout) :: kx real(kind=8), intent(inout) :: ky public  subroutine COMPUTE_SC (Hamiltonian, kx, ky, Gamma_SC) Arguments Type Intent Optional Attributes Name complex(kind=16), intent(inout) :: Hamiltonian (DIM,DIM) real(kind=8), intent(in) :: kx real(kind=8), intent(in) :: ky complex(kind=16), intent(in) :: Gamma_SC (ORBITALS,N_ALL_NEIGHBOURS,2,SUBLATTICES) public  subroutine COMPUTE_HUBBARD (Hamiltonian, Charge_dens) Arguments Type Intent Optional Attributes Name complex(kind=16), intent(inout) :: Hamiltonian (DIM,DIM) real(kind=8), intent(in) :: Charge_dens (DIM_POSITIVE_K) public  subroutine COMPUTE_ZEEMAN (Bfield, Hamiltonian) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: Bfield (3) complex(kind=16), intent(inout) :: Hamiltonian (DIM,DIM) public  subroutine DIAGONAL_TBA (Hamiltonian, kx, ky) Arguments Type Intent Optional Attributes Name complex(kind=16), intent(inout) :: Hamiltonian (DIM,DIM) real(kind=8), intent(inout) :: kx real(kind=8), intent(inout) :: ky","tags":"","loc":"module/mod_hamiltonians.html"},{"title":"mod_reader – Fortran Program","text":"Uses mod_parameters Variables Type Visibility Attributes Name Initial real(kind=8), public :: T = 0. real(kind=8), public :: t_D = 0. real(kind=8), public :: t_I = 0. real(kind=8), public :: lambda_SOC = 0. real(kind=8), public :: DELTA_TRI = 0. real(kind=8), public :: v = 0. real(kind=8), public :: V_pdp = 0. real(kind=8), public :: V_pds = 0. real(kind=8), public :: J_SC = 0. real(kind=8), public :: J_SC_PRIME = 0. real(kind=8), public :: J_SC_NNN = 0. real(kind=8), public :: J_SC_PRIME_NNN = 0. real(kind=8), public :: U_HUB = 0. real(kind=8), public :: V_HUB = 0. real(kind=8), public :: E_Fermi = 0. integer(kind=4), public :: k1_steps = 0 integer(kind=4), public :: k2_steps = 0 real(kind=8), public :: gamma_start = 0. real(kind=8), public :: charge_start = 0. integer(kind=4), public :: max_sc_iter = 0 real(kind=8), public :: sc_alpha = 0. real(kind=8), public :: sc_alpha_adapt = 0. real(kind=8), public :: gamma_eps_convergence = 0. real(kind=8), public :: charge_eps_convergence = 0. real(kind=8), public :: romb_eps_x = 0. integer(kind=4), public :: interpolation_deg_x = 0 integer(kind=4), public :: max_grid_refinements_x = 0 real(kind=8), public :: romb_eps_y = 0. integer(kind=4), public :: interpolation_deg_y = 0 integer(kind=4), public :: max_grid_refinements_y = 0 real(kind=8), public :: eta_p real(kind=8), public :: dk1 real(kind=8), public :: dk2 real(kind=8), public :: domega Subroutines public  subroutine GET_INPUT (nmlfile) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: nmlfile public  subroutine GET_GAMMA_SC (Gamma_SC, path) Arguments Type Intent Optional Attributes Name complex(kind=16), intent(out) :: Gamma_SC (ORBITALS,N_ALL_NEIGHBOURS,2,SUBLATTICES) character(len=*), intent(in) :: path public  subroutine GET_CHARGE_DENS (Charge_dens, path) Arguments Type Intent Optional Attributes Name real(kind=8), intent(out) :: Charge_dens (DIM_POSITIVE_K) character(len=*), intent(in) :: path","tags":"","loc":"module/mod_reader.html"},{"title":"mod_compute_hamiltonians – Fortran Program","text":"Uses mod_hamiltonians mod_utilities mod_writers mod_parameters Subroutines public  subroutine GET_LOCAL_CHARGE_AND_DELTA (Hamiltonian_const, Gamma_SC, Charge_dens, k1, k2, Delta_local, Charge_dens_local) Arguments Type Intent Optional Attributes Name complex(kind=16), intent(in) :: Hamiltonian_const (DIM,DIM) complex(kind=16), intent(in) :: Gamma_SC (ORBITALS,N_ALL_NEIGHBOURS,2,SUBLATTICES) real(kind=8), intent(in) :: Charge_dens (DIM_POSITIVE_K) real(kind=8), intent(in) :: k1 real(kind=8), intent(in) :: k2 complex(kind=16), intent(out) :: Delta_local (ORBITALS,N_ALL_NEIGHBOURS,2,SUBLATTICES) real(kind=8), intent(out) :: Charge_dens_local (DIM_POSITIVE_K)","tags":"","loc":"module/mod_compute_hamiltonians.html"},{"title":"mod_integrate – Fortran Program","text":"Uses mod_compute_hamiltonians mod_parameters Subroutines public  subroutine ROMBERG_Y (Hamiltonian_const, Gamma_SC, Charge_dens, k1_chunk_min, k1_chunk_max, k2_chunk_min, k2_chunk_max, Delta_local, Charge_dens_local, romb_eps_x, interpolation_deg_x, max_grid_refinements_x, romb_eps_y, interpolation_deg_y, max_grid_refinements_y) !!!!!! THIS PART COULD LEAD TO A PROBLEM !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Read more… Arguments Type Intent Optional Attributes Name complex(kind=16), intent(in) :: Hamiltonian_const (DIM,DIM) complex(kind=16), intent(in) :: Gamma_SC (ORBITALS,N_ALL_NEIGHBOURS,2,SUBLATTICES) real(kind=8), intent(in) :: Charge_dens (DIM_POSITIVE_K) real(kind=8), intent(in) :: k1_chunk_min real(kind=8), intent(in) :: k1_chunk_max real(kind=8), intent(in) :: k2_chunk_min real(kind=8), intent(in) :: k2_chunk_max complex(kind=16), intent(out) :: Delta_local (ORBITALS,N_ALL_NEIGHBOURS,2,SUBLATTICES) real(kind=8), intent(out) :: Charge_dens_local (DIM_POSITIVE_K) real(kind=8), intent(in) :: romb_eps_x integer(kind=4), intent(in) :: interpolation_deg_x integer(kind=4), intent(in) :: max_grid_refinements_x real(kind=8), intent(in) :: romb_eps_y integer(kind=4), intent(in) :: interpolation_deg_y integer(kind=4), intent(in) :: max_grid_refinements_y public  subroutine ROMBERG_X (Hamiltonian_const, Gamma_SC, Charge_dens, k1_chunk_min, k1_chunk_max, k2_actual, Delta_local, Charge_dens_local, romb_eps_x, interpolation_deg_x, max_grid_refinements_x) !!!!!! THIS PART COULD LEAD TO A PROBLEM !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Read more… Arguments Type Intent Optional Attributes Name complex(kind=16), intent(in) :: Hamiltonian_const (DIM,DIM) complex(kind=16), intent(in) :: Gamma_SC (ORBITALS,N_ALL_NEIGHBOURS,2,SUBLATTICES) real(kind=8), intent(in) :: Charge_dens (DIM_POSITIVE_K) real(kind=8), intent(in) :: k1_chunk_min real(kind=8), intent(in) :: k1_chunk_max real(kind=8), intent(in) :: k2_actual complex(kind=16), intent(out) :: Delta_local (ORBITALS,N_ALL_NEIGHBOURS,2,SUBLATTICES) real(kind=8), intent(out) :: Charge_dens_local (DIM_POSITIVE_K) real(kind=8), intent(in) :: romb_eps_x integer(kind=4), intent(in) :: interpolation_deg_x integer(kind=4), intent(in) :: max_grid_refinements_x public  subroutine POLINT (X, Y, deg, x_target, y_approx, dy) Arguments Type Intent Optional Attributes Name complex(kind=16), intent(in) :: X (deg) complex(kind=16), intent(in) :: Y (deg) integer(kind=4), intent(in) :: deg complex(kind=16), intent(in) :: x_target complex(kind=16), intent(out) :: y_approx complex(kind=16), intent(out) :: dy","tags":"","loc":"module/mod_integrate.html"},{"title":"mod_broydenV2 – Fortran Program","text":"Subroutines public  subroutine mix_broyden (ndim, deltaout, deltain, alphamix, iter, n_iter, conv) Modified Broyden's method for potential/charge density mixing\n            D.D.Johnson, PRB 38, 12807 (1988) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ndim Dimension of arrays deltaout, deltain real(kind=8), intent(inout) :: deltaout (ndim) output Delta at current iteration real(kind=8), intent(inout) :: deltain (ndim) Delta at previous iteration real(kind=8), intent(in) :: alphamix Mixing factor (0 < alphamix <= 1) integer, intent(in) :: iter Current iteration number integer, intent(in) :: n_iter Number of iterations used in the mixing logical, intent(in) :: conv If true convergence reache","tags":"","loc":"module/mod_broydenv2.html"},{"title":"mod_utilities – Fortran Program","text":"Uses mod_reader mod_parameters Functions public pure function epsilon_yz (kx, ky) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: kx real(kind=8), intent(in) :: ky Return Value complex(kind=16) public pure function epsilon_zx (kx, ky) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: kx real(kind=8), intent(in) :: ky Return Value complex(kind=16) public pure function epsilon_xy (kx, ky) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: kx real(kind=8), intent(in) :: ky Return Value complex(kind=16) public pure function pairing_1 (ky) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: ky Return Value complex(kind=16) public pure function pairing_2 (kx, ky) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: kx real(kind=8), intent(in) :: ky Return Value complex(kind=16) public pure function pairing_3 (kx, ky) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: kx real(kind=8), intent(in) :: ky Return Value complex(kind=16) public pure function pairing_nnn_1 (kx) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: kx Return Value complex(kind=16) public pure function pairing_nnn_2 (kx, ky) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: kx real(kind=8), intent(in) :: ky Return Value complex(kind=16) public pure function pairing_nnn_3 (kx, ky) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: kx real(kind=8), intent(in) :: ky Return Value complex(kind=16) public pure function pairing_nnn_4 (kx) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: kx Return Value complex(kind=16) public pure function pairing_nnn_5 (kx, ky) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: kx real(kind=8), intent(in) :: ky Return Value complex(kind=16) public pure function pairing_nnn_6 (kx, ky) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: kx real(kind=8), intent(in) :: ky Return Value complex(kind=16) public pure function fd_distribution (E, E_Fermi, T) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: E real(kind=8), intent(in) :: E_Fermi real(kind=8), intent(in) :: T Return Value real(kind=8) public  function dirac_delta (E, omega, zeta) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: E real(kind=8), intent(in) :: omega real(kind=8), intent(in) :: zeta Return Value real(kind=8) public  function meV_to_au (x) Arguments Type Intent Optional Attributes Name real(kind=8) :: x Return Value real(kind=8) public  function nm_to_au (x) Arguments Type Intent Optional Attributes Name real(kind=8) :: x Return Value real(kind=8) public  function au_to_meV (x) Arguments Type Intent Optional Attributes Name real(kind=8) :: x Return Value real(kind=8) public  function au_to_nm (x) Arguments Type Intent Optional Attributes Name real(kind=8) :: x Return Value real(kind=8) Subroutines public  subroutine DIAGONALIZE_HERMITIAN (Hamiltonian, Eigenvalues, N) Arguments Type Intent Optional Attributes Name complex(kind=16), intent(inout) :: Hamiltonian (N,N) real(kind=8), intent(out) :: Eigenvalues (N) integer(kind=4), intent(in) :: N public  subroutine DIAGONALIZE_GENERALIZED (Hamiltonian, Eigenvalues, U_transformation, N) Arguments Type Intent Optional Attributes Name complex(kind=16), intent(inout) :: Hamiltonian (N,N) real(kind=8), intent(out) :: Eigenvalues (N) complex(kind=16), intent(inout) :: U_transformation (N,N) integer(kind=4), intent(in) :: N public  subroutine COMPUTE_CONJUGATE_ELEMENTS (Hamiltonian, N) Arguments Type Intent Optional Attributes Name complex(kind=16), intent(inout) :: Hamiltonian (N,N) integer(kind=4), intent(in) :: N","tags":"","loc":"module/mod_utilities.html"},{"title":"mod_writers – Fortran Program","text":"Uses mod_parameters Subroutines public  subroutine PRINT_HAMILTONIAN (Hamiltonian) Arguments Type Intent Optional Attributes Name complex(kind=16), intent(in) :: Hamiltonian (DIM,DIM) public  subroutine PRINT_ENERGIES (Energies, k1_steps, k2_steps, dk1, dk2, filename, N) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: Energies (0:k1_steps,0:k2_steps,N) integer(kind=4), intent(in) :: k1_steps integer(kind=4), intent(in) :: k2_steps real(kind=8), intent(in) :: dk1 real(kind=8), intent(in) :: dk2 character(len=*), intent(in) :: filename integer(kind=4), intent(in) :: N public  subroutine PRINT_GAMMA (Gamma_SC, filename) Arguments Type Intent Optional Attributes Name complex(kind=16), intent(in) :: Gamma_SC (ORBITALS,N_ALL_NEIGHBOURS,2,SUBLATTICES) character(len=*), intent(in) :: filename public  subroutine PRINT_CHARGE (Charge_dens, filename) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: Charge_dens (DIM_POSITIVE_K) character(len=*), intent(in) :: filename","tags":"","loc":"module/mod_writers.html"},{"title":"mod_postprocessing – Fortran Program","text":"Uses mod_reader mod_parameters mod_compute_hamiltonians mod_writers mod_hamiltonians mod_utilities Functions public  function det (matrix, n) Arguments Type Intent Optional Attributes Name complex(kind=16), intent(in) :: matrix (n,n) integer(kind=4), intent(in) :: n Return Value complex(kind=16) Subroutines public  subroutine CALCULATE_DOS (E_DOS_min, E_DOS_max, dE0, zeta_DOS, DOS_filename) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: E_DOS_min real(kind=8), intent(in) :: E_DOS_max real(kind=8), intent(in) :: dE0 real(kind=8), intent(in) :: zeta_DOS character(len=*), intent(in) :: DOS_filename public  subroutine CALCULATE_DISPERSION (filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename public  subroutine CALCULATE_CHERN_PARAMS (Nk1, Nk2, HamDim) Calculates Chern Params, based on https://arxiv.org/abs/cond-mat/0503172 Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in) :: Nk1 Number of divisions along k1 integer(kind=4), intent(in) :: Nk2 Number of divisions along k2 integer(kind=4), intent(in) :: HamDim DImension of the hamiltonian to be diagonalized (e.g. 4 for simple hellical, 24 for LAO-STO) public  subroutine HELLICAL_TEST_CHERN (potChem, B, Nk1, Nk2, i, j, U_transformation) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: potChem real(kind=8), intent(in) :: B (3) integer(kind=4), intent(in) :: Nk1 integer(kind=4), intent(in) :: Nk2 integer(kind=4), intent(in) :: i integer(kind=4), intent(in) :: j complex(kind=16), intent(inout) :: U_transformation (HamDim,HamDim) public  subroutine LAO_STO_CHERN_ENERGIES (Nk1, Nk2, i, j, run_dir, U_transformation) This subroutine calculates energies and wavefunctions of LAO-STO in [111] direction.\nReturns sorted wavefunctions in (i,j) point of the Brillouin zone. Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in) :: Nk1 Number of divisions of Brillouin zone in direction k1. integer(kind=4), intent(in) :: Nk2 Number of divisions of Brillouin zone in direction k2. integer(kind=4), intent(in) :: i Curent point k1_i in the Brillouin zone integer(kind=4), intent(in) :: j Curent point k2_j in the Brillouin zone character(len=*), intent(in) :: run_dir Directory of the run, where input.nml should be placed.\nIt contains material information and physical parameter of calculation:\nFermi energy, temperature etc. complex(kind=16), intent(out) :: U_transformation (DIM,DIM) Matrix containing eigenvectors stored in consecutive columns.\nOn output sorted based on energies from lowest to highest. public  subroutine SORT_ENERGIES_AND_WAVEFUNCTIONS (Energies, Psi, HamDim) Arguments Type Intent Optional Attributes Name real(kind=8), intent(inout) :: Energies (HamDim) complex(kind=16), intent(inout) :: Psi (HamDim,HamDim) integer(kind=4), intent(in) :: HamDim","tags":"","loc":"module/mod_postprocessing.html"},{"title":"Tests – Fortran Program","text":"Uses mod_hamiltonians mod_reader mod_writers mod_parameters Variables Type Attributes Name Initial complex(kind=16), ALLOCATABLE :: Hamiltonian (:,:) real(kind=8), ALLOCATABLE :: Charge_dens (:)","tags":"","loc":"program/tests.html"},{"title":"MAIN – Fortran Program","text":"Uses mod_reader mod_integrate mod_parameters mod_compute_hamiltonians mod_broydenV2 mod_writers mod_hamiltonians mod_utilities Variables Type Attributes Name Initial complex(kind=16), ALLOCATABLE :: Hamiltonian (:,:) complex(kind=16), ALLOCATABLE :: Hamiltonian_const (:,:) complex(kind=16), ALLOCATABLE :: U_transformation (:,:) real(kind=8), ALLOCATABLE :: Energies (:) complex(kind=16), ALLOCATABLE :: Delta_local (:,:,:,:) complex(kind=16), ALLOCATABLE :: Delta_new (:,:,:,:) real(kind=8), ALLOCATABLE :: Delta_broyden (:) real(kind=8), ALLOCATABLE :: Delta_new_broyden (:) complex(kind=16), ALLOCATABLE :: Gamma_SC (:,:,:,:) complex(kind=16), ALLOCATABLE :: Gamma_SC_new (:,:,:,:) real(kind=8), ALLOCATABLE :: Charge_dens (:) real(kind=8), ALLOCATABLE :: Charge_dens_new (:) real(kind=8), ALLOCATABLE :: Charge_dens_local (:) real(kind=8) :: gamma_error real(kind=8) :: gamma_max_error real(kind=8) :: charge_error real(kind=8) :: charge_max_error real(kind=8) :: gamma_max_error_prev real(kind=8) :: charge_max_error_prev integer(kind=4) :: i integer(kind=4) :: j integer(kind=4) :: n integer(kind=4) :: lat integer(kind=4) :: orb integer(kind=4) :: orb_prime integer(kind=4) :: spin integer(kind=4) :: sc_iter logical :: sc_flag integer(kind=4) :: counter integer(kind=4) :: delta_real_elems integer(kind=4) :: broyden_index","tags":"","loc":"program/main.html"},{"title":"main_postprocessing – Fortran Program","text":"Uses mod_reader mod_parameters mod_compute_hamiltonians mod_writers mod_postprocessing mod_hamiltonians mod_utilities Variables Type Attributes Name Initial real(kind=8) :: zeta integer(kind=4) :: Nk integer(kind=4) :: HamDim","tags":"","loc":"program/main_postprocessing.html"},{"title":"mod_hamiltonians.f90 – Fortran Program","text":"Source Code MODULE mod_hamiltonians USE mod_utilities USE mod_parameters USE mod_reader IMPLICIT NONE CONTAINS SUBROUTINE COMPUTE_TBA_TERM ( Hamiltonian , kx , ky ) IMPLICIT NONE REAL * 8 , INTENT ( INOUT ) :: kx , ky COMPLEX * 16 , INTENT ( INOUT ) :: Hamiltonian ( DIM , DIM ) !Twice as big because of spin !Only specifying upper triangle of matrix, since Hamiltonian is hermitian !spin up Hamiltonian ( 1 , 4 ) = epsilon_yz ( kx , ky ) Hamiltonian ( 2 , 5 ) = epsilon_zx ( kx , ky ) Hamiltonian ( 3 , 6 ) = epsilon_xy ( kx , ky ) !spin down Hamiltonian ( TBA_DIM + 1 , TBA_DIM + 4 ) = epsilon_yz ( kx , ky ) Hamiltonian ( TBA_DIM + 2 , TBA_DIM + 5 ) = epsilon_zx ( kx , ky ) Hamiltonian ( TBA_DIM + 3 , TBA_DIM + 6 ) = epsilon_xy ( kx , ky ) !Nambu space: H(k) -> -H(-k) kx = - kx ky = - ky !spin up Hamiltonian ( DIM_POSITIVE_K + 1 , DIM_POSITIVE_K + 4 ) = - CONJG ( epsilon_yz ( kx , ky )) Hamiltonian ( DIM_POSITIVE_K + 2 , DIM_POSITIVE_K + 5 ) = - CONJG ( epsilon_zx ( kx , ky )) Hamiltonian ( DIM_POSITIVE_K + 3 , DIM_POSITIVE_K + 6 ) = - CONJG ( epsilon_xy ( kx , ky )) !spin down Hamiltonian ( DIM_POSITIVE_K + TBA_DIM + 1 , DIM_POSITIVE_K + TBA_DIM + 4 ) = - CONJG ( epsilon_yz ( kx , ky )) Hamiltonian ( DIM_POSITIVE_K + TBA_DIM + 2 , DIM_POSITIVE_K + TBA_DIM + 5 ) = - CONJG ( epsilon_zx ( kx , ky )) Hamiltonian ( DIM_POSITIVE_K + TBA_DIM + 3 , DIM_POSITIVE_K + TBA_DIM + 6 ) = - CONJG ( epsilon_xy ( kx , ky )) kx = - kx ky = - ky END SUBROUTINE COMPUTE_TBA_TERM SUBROUTINE COMPUTE_ATOMIC_SOC_TERMS ( Hamiltonian ) IMPLICIT NONE COMPLEX * 16 , INTENT ( INOUT ) :: Hamiltonian ( DIM , DIM ) !Ti1 atoms Hamiltonian ( 1 , 2 ) = Hamiltonian ( 1 , 2 ) + imag * lambda_SOC / 2. Hamiltonian ( 7 , 8 ) = Hamiltonian ( 7 , 8 ) - imag * lambda_SOC / 2. Hamiltonian ( 1 , 9 ) = Hamiltonian ( 1 , 9 ) - lambda_SOC / 2. Hamiltonian ( 2 , 9 ) = Hamiltonian ( 2 , 9 ) + imag * lambda_SOC / 2. Hamiltonian ( 3 , 7 ) = Hamiltonian ( 3 , 7 ) + lambda_SOC / 2. Hamiltonian ( 3 , 8 ) = Hamiltonian ( 3 , 8 ) - imag * lambda_SOC / 2. !Ti2 atoms Hamiltonian ( 4 , 5 ) = Hamiltonian ( 4 , 5 ) + imag * lambda_SOC / 2. Hamiltonian ( 10 , 11 ) = Hamiltonian ( 10 , 11 ) - imag * lambda_SOC / 2. Hamiltonian ( 4 , 12 ) = Hamiltonian ( 4 , 12 ) - lambda_SOC / 2. Hamiltonian ( 5 , 12 ) = Hamiltonian ( 5 , 12 ) + imag * lambda_SOC / 2. Hamiltonian ( 6 , 10 ) = Hamiltonian ( 6 , 10 ) + lambda_SOC / 2. Hamiltonian ( 6 , 11 ) = Hamiltonian ( 6 , 11 ) - imag * lambda_SOC / 2. !Nambu space !Ti1 atoms Hamiltonian ( DIM_POSITIVE_K + 1 , DIM_POSITIVE_K + 2 ) = Hamiltonian ( DIM_POSITIVE_K + 1 , DIM_POSITIVE_K + 2 ) + imag * lambda_SOC / 2. Hamiltonian ( DIM_POSITIVE_K + 7 , DIM_POSITIVE_K + 8 ) = Hamiltonian ( DIM_POSITIVE_K + 7 , DIM_POSITIVE_K + 8 ) - imag * lambda_SOC / 2. Hamiltonian ( DIM_POSITIVE_K + 1 , DIM_POSITIVE_K + 9 ) = Hamiltonian ( DIM_POSITIVE_K + 1 , DIM_POSITIVE_K + 9 ) + lambda_SOC / 2. Hamiltonian ( DIM_POSITIVE_K + 2 , DIM_POSITIVE_K + 9 ) = Hamiltonian ( DIM_POSITIVE_K + 2 , DIM_POSITIVE_K + 9 ) + imag * lambda_SOC / 2. Hamiltonian ( DIM_POSITIVE_K + 3 , DIM_POSITIVE_K + 7 ) = Hamiltonian ( DIM_POSITIVE_K + 3 , DIM_POSITIVE_K + 7 ) - lambda_SOC / 2. Hamiltonian ( DIM_POSITIVE_K + 3 , DIM_POSITIVE_K + 8 ) = Hamiltonian ( DIM_POSITIVE_K + 3 , DIM_POSITIVE_K + 8 ) - imag * lambda_SOC / 2. !Ti2 atoms Hamiltonian ( DIM_POSITIVE_K + 4 , DIM_POSITIVE_K + 5 ) = Hamiltonian ( DIM_POSITIVE_K + 4 , DIM_POSITIVE_K + 5 ) + imag * lambda_SOC / 2. Hamiltonian ( DIM_POSITIVE_K + 10 , DIM_POSITIVE_K + 11 ) = Hamiltonian ( DIM_POSITIVE_K + 10 , DIM_POSITIVE_K + 11 ) - imag * lambda_SOC / 2. Hamiltonian ( DIM_POSITIVE_K + 4 , DIM_POSITIVE_K + 12 ) = Hamiltonian ( DIM_POSITIVE_K + 4 , DIM_POSITIVE_K + 2 ) + lambda_SOC / 2. Hamiltonian ( DIM_POSITIVE_K + 5 , DIM_POSITIVE_K + 12 ) = Hamiltonian ( DIM_POSITIVE_K + 5 , DIM_POSITIVE_K + 2 ) + imag * lambda_SOC / 2. Hamiltonian ( DIM_POSITIVE_K + 6 , DIM_POSITIVE_K + 10 ) = Hamiltonian ( DIM_POSITIVE_K + 6 , DIM_POSITIVE_K + 0 ) - lambda_SOC / 2. Hamiltonian ( DIM_POSITIVE_K + 6 , DIM_POSITIVE_K + 11 ) = Hamiltonian ( DIM_POSITIVE_K + 6 , DIM_POSITIVE_K + 1 ) - imag * lambda_SOC / 2. END SUBROUTINE COMPUTE_ATOMIC_SOC_TERMS SUBROUTINE COMPUTE_TRIGONAL_TERMS ( Hamiltonian ) IMPLICIT NONE COMPLEX * 16 , INTENT ( INOUT ) :: Hamiltonian ( DIM , DIM ) !Spin up !Ti 1 atoms Hamiltonian ( 1 , 2 ) = Hamiltonian ( 1 , 2 ) + DELTA_TRI / 2. Hamiltonian ( 1 , 3 ) = Hamiltonian ( 1 , 3 ) + DELTA_TRI / 2. Hamiltonian ( 2 , 3 ) = Hamiltonian ( 2 , 3 ) + DELTA_TRI / 2. !Ti 2 atoms Hamiltonian ( ORBITALS + 1 , ORBITALS + 2 ) = Hamiltonian ( ORBITALS + 1 , ORBITALS + 2 ) + DELTA_TRI / 2. Hamiltonian ( ORBITALS + 1 , ORBITALS + 3 ) = Hamiltonian ( ORBITALS + 1 , ORBITALS + 3 ) + DELTA_TRI / 2. Hamiltonian ( ORBITALS + 2 , ORBITALS + 3 ) = Hamiltonian ( ORBITALS + 2 , ORBITALS + 3 ) + DELTA_TRI / 2. !Spin down !Ti 1 atoms Hamiltonian ( 1 + TBA_DIM , 2 + TBA_DIM ) = Hamiltonian ( 1 + TBA_DIM , 2 + TBA_DIM ) + DELTA_TRI / 2. Hamiltonian ( 1 + TBA_DIM , 3 + TBA_DIM ) = Hamiltonian ( 1 + TBA_DIM , 3 + TBA_DIM ) + DELTA_TRI / 2. Hamiltonian ( 2 + TBA_DIM , 3 + TBA_DIM ) = Hamiltonian ( 2 + TBA_DIM , 3 + TBA_DIM ) + DELTA_TRI / 2. !Ti 2 atoms Hamiltonian ( 1 + ORBITALS + TBA_DIM , 2 + ORBITALS + TBA_DIM ) = Hamiltonian ( 1 + ORBITALS + TBA_DIM , 2 + ORBITALS + TBA_DIM ) + DELTA_TRI / 2. Hamiltonian ( 1 + ORBITALS + TBA_DIM , 3 + ORBITALS + TBA_DIM ) = Hamiltonian ( 1 + ORBITALS + TBA_DIM , 3 + ORBITALS + TBA_DIM ) + DELTA_TRI / 2. Hamiltonian ( 2 + ORBITALS + TBA_DIM , 3 + ORBITALS + TBA_DIM ) = Hamiltonian ( 2 + ORBITALS + TBA_DIM , 3 + ORBITALS + TBA_DIM ) + DELTA_TRI / 2. !Nambu space !Spin up !Ti 1 atoms Hamiltonian ( DIM_POSITIVE_K + 1 , DIM_POSITIVE_K + 2 ) = Hamiltonian ( DIM_POSITIVE_K + 1 , DIM_POSITIVE_K + 2 ) - DELTA_TRI / 2. Hamiltonian ( DIM_POSITIVE_K + 1 , DIM_POSITIVE_K + 3 ) = Hamiltonian ( DIM_POSITIVE_K + 1 , DIM_POSITIVE_K + 3 ) - DELTA_TRI / 2. Hamiltonian ( DIM_POSITIVE_K + 2 , DIM_POSITIVE_K + 3 ) = Hamiltonian ( DIM_POSITIVE_K + 2 , DIM_POSITIVE_K + 3 ) - DELTA_TRI / 2. !Ti 2 atoms Hamiltonian ( DIM_POSITIVE_K + ORBITALS + 1 , DIM_POSITIVE_K + ORBITALS + 2 ) = Hamiltonian ( DIM_POSITIVE_K + ORBITALS + 1 , DIM_POSITIVE_K + ORBITALS + 2 ) - DELTA_TRI / 2. Hamiltonian ( DIM_POSITIVE_K + ORBITALS + 1 , DIM_POSITIVE_K + ORBITALS + 3 ) = Hamiltonian ( DIM_POSITIVE_K + ORBITALS + 1 , DIM_POSITIVE_K + ORBITALS + 3 ) - DELTA_TRI / 2. Hamiltonian ( DIM_POSITIVE_K + ORBITALS + 2 , DIM_POSITIVE_K + ORBITALS + 3 ) = Hamiltonian ( DIM_POSITIVE_K + ORBITALS + 2 , DIM_POSITIVE_K + ORBITALS + 3 ) - DELTA_TRI / 2. !Spin down !Ti 1 atoms Hamiltonian ( DIM_POSITIVE_K + 1 + TBA_DIM , DIM_POSITIVE_K + 2 + TBA_DIM ) = Hamiltonian ( DIM_POSITIVE_K + 1 + TBA_DIM , DIM_POSITIVE_K + 2 + TBA_DIM ) - DELTA_TRI / 2. Hamiltonian ( DIM_POSITIVE_K + 1 + TBA_DIM , DIM_POSITIVE_K + 3 + TBA_DIM ) = Hamiltonian ( DIM_POSITIVE_K + 1 + TBA_DIM , DIM_POSITIVE_K + 3 + TBA_DIM ) - DELTA_TRI / 2. Hamiltonian ( DIM_POSITIVE_K + 2 + TBA_DIM , DIM_POSITIVE_K + 3 + TBA_DIM ) = Hamiltonian ( DIM_POSITIVE_K + 2 + TBA_DIM , DIM_POSITIVE_K + 3 + TBA_DIM ) - DELTA_TRI / 2. !Ti 2 atoms Hamiltonian ( 1 + ORBITALS + TBA_DIM + DIM_POSITIVE_K , 2 + ORBITALS + TBA_DIM + DIM_POSITIVE_K ) = Hamiltonian ( 1 + ORBITALS + TBA_DIM + DIM_POSITIVE_K , 2 + ORBITALS + TBA_DIM + DIM_POSITIVE_K ) - DELTA_TRI / 2. Hamiltonian ( 1 + ORBITALS + TBA_DIM + DIM_POSITIVE_K , 3 + ORBITALS + TBA_DIM + DIM_POSITIVE_K ) = Hamiltonian ( 1 + ORBITALS + TBA_DIM + DIM_POSITIVE_K , 3 + ORBITALS + TBA_DIM + DIM_POSITIVE_K ) - DELTA_TRI / 2. Hamiltonian ( 2 + ORBITALS + TBA_DIM + DIM_POSITIVE_K , 3 + ORBITALS + TBA_DIM + DIM_POSITIVE_K ) = Hamiltonian ( 2 + ORBITALS + TBA_DIM + DIM_POSITIVE_K , 3 + ORBITALS + TBA_DIM + DIM_POSITIVE_K ) - DELTA_TRI / 2. END SUBROUTINE COMPUTE_TRIGONAL_TERMS SUBROUTINE COMPUTE_ELECTRIC_FIELD ( Hamiltonian ) IMPLICIT NONE COMPLEX * 16 , INTENT ( INOUT ) :: Hamiltonian ( DIM , DIM ) INTEGER * 4 :: i DO i = 1 , 3 !Ti1 atoms Hamiltonian ( i , i ) = Hamiltonian ( i , i ) + v / 2. Hamiltonian ( i + TBA_DIM , i + TBA_DIM ) = Hamiltonian ( i + TBA_DIM , i + TBA_DIM ) + v / 2. !Ti2 atoms Hamiltonian ( i + ORBITALS , i + ORBITALS ) = Hamiltonian ( i + ORBITALS , i + ORBITALS ) - v / 2. Hamiltonian ( i + TBA_DIM + ORBITALS , i + TBA_DIM + ORBITALS ) = Hamiltonian ( i + TBA_DIM + ORBITALS , i + TBA_DIM + ORBITALS ) - v / 2 !Nambu space !Ti1 atoms Hamiltonian ( DIM_POSITIVE_K + i , DIM_POSITIVE_K + i ) = Hamiltonian ( DIM_POSITIVE_K + i , DIM_POSITIVE_K + i ) - v / 2. Hamiltonian ( i + TBA_DIM + DIM_POSITIVE_K , i + TBA_DIM + DIM_POSITIVE_K ) = Hamiltonian ( i + TBA_DIM + DIM_POSITIVE_K , i + TBA_DIM + DIM_POSITIVE_K ) - v / 2. !Ti2 atoms Hamiltonian ( i + ORBITALS + DIM_POSITIVE_K , i + ORBITALS + DIM_POSITIVE_K ) = Hamiltonian ( i + ORBITALS + DIM_POSITIVE_K , i + ORBITALS + DIM_POSITIVE_K ) + v / 2. Hamiltonian ( i + TBA_DIM + ORBITALS + DIM_POSITIVE_K , i + TBA_DIM + ORBITALS + DIM_POSITIVE_K ) = Hamiltonian ( i + TBA_DIM + ORBITALS + DIM_POSITIVE_K , i + TBA_DIM + ORBITALS + DIM_POSITIVE_K ) + v / 2 END DO END SUBROUTINE COMPUTE_ELECTRIC_FIELD SUBROUTINE COMPUTE_TI1_TI2 ( Hamiltonian , kx , ky ) IMPLICIT NONE COMPLEX * 16 , INTENT ( INOUT ) :: Hamiltonian ( DIM , DIM ) REAL * 8 , INTENT ( INOUT ) :: kx , ky !Spin-up part Hamiltonian ( 1 , 2 + ORBITALS ) = Hamiltonian ( 1 , 2 + ORBITALS ) + eta_p * V_pdp * SQRT ( 2. ) ** ( 7. / 4. ) / SQRT ( 1 5. ) * ( - 2. * imag * EXP ( imag * 3. / 2. * ky ) * SIN ( SQRT ( 3. ) / 2. * kx )) Hamiltonian ( 1 , 3 + ORBITALS ) = Hamiltonian ( 1 , 3 + ORBITALS ) + eta_p * V_pdp * SQRT ( 2. ) ** ( 7. / 4. ) / SQRT ( 1 5. ) * ( 1 - EXP ( imag / 2. * ( SQRT ( 3. ) * kx + 3. * ky ))) Hamiltonian ( 2 , 1 + ORBITALS ) = Hamiltonian ( 2 , 1 + ORBITALS ) + eta_p * V_pdp * SQRT ( 2. ) ** ( 7. / 4. ) / SQRT ( 1 5. ) * ( 2 * imag * EXP ( imag * 3. / 2. * ky ) * SIN ( SQRT ( 3. ) / 2. * kx )) Hamiltonian ( 2 , 3 + ORBITALS ) = Hamiltonian ( 2 , 3 + ORBITALS ) + eta_p * V_pdp * SQRT ( 2. ) ** ( 7. / 4. ) / SQRT ( 1 5. ) * ( 1 - EXP ( - imag / 2. * ( SQRT ( 3. ) * kx - 3. * ky ))) Hamiltonian ( 3 , 1 + ORBITALS ) = Hamiltonian ( 3 , 1 + ORBITALS ) + eta_p * V_pdp * SQRT ( 2. ) ** ( 7. / 4. ) / SQRT ( 1 5. ) * ( - 1 + EXP ( imag / 2. * ( SQRT ( 3. ) * kx + 3. * ky ))) Hamiltonian ( 3 , 2 + ORBITALS ) = Hamiltonian ( 3 , 2 + ORBITALS ) + eta_p * V_pdp * SQRT ( 2. ) ** ( 7. / 4. ) / SQRT ( 1 5. ) * ( - 1 + EXP ( - imag / 2. * ( SQRT ( 3. ) * kx - 3. * ky ))) !Spin-down part Hamiltonian ( 1 + TBA_DIM , 2 + ORBITALS + TBA_DIM ) = Hamiltonian ( 1 + TBA_DIM , 2 + ORBITALS + TBA_DIM ) + eta_p * V_pdp * SQRT ( 2. ) ** ( 7. / 4. ) / SQRT ( 1 5. ) * ( - 2. * imag * EXP ( imag * 3. / 2. * ky ) * SIN ( SQRT ( 3. ) / 2. * kx )) Hamiltonian ( 1 + TBA_DIM , 3 + ORBITALS + TBA_DIM ) = Hamiltonian ( 1 + TBA_DIM , 3 + ORBITALS + TBA_DIM ) + eta_p * V_pdp * SQRT ( 2. ) ** ( 7. / 4. ) / SQRT ( 1 5. ) * ( 1 - EXP ( imag / 2. * ( SQRT ( 3. ) * kx + 3. * ky ))) Hamiltonian ( 2 + TBA_DIM , 1 + ORBITALS + TBA_DIM ) = Hamiltonian ( 2 + TBA_DIM , 1 + ORBITALS + TBA_DIM ) + eta_p * V_pdp * SQRT ( 2. ) ** ( 7. / 4. ) / SQRT ( 1 5. ) * ( 2 * imag * EXP ( imag * 3. / 2. * ky ) * SIN ( SQRT ( 3. ) / 2. * kx )) Hamiltonian ( 2 + TBA_DIM , 3 + ORBITALS + TBA_DIM ) = Hamiltonian ( 2 + TBA_DIM , 3 + ORBITALS + TBA_DIM ) + eta_p * V_pdp * SQRT ( 2. ) ** ( 7. / 4. ) / SQRT ( 1 5. ) * ( 1 - EXP ( - imag / 2. * ( SQRT ( 3. ) * kx - 3. * ky ))) Hamiltonian ( 3 + TBA_DIM , 1 + ORBITALS + TBA_DIM ) = Hamiltonian ( 3 + TBA_DIM , 1 + ORBITALS + TBA_DIM ) + eta_p * V_pdp * SQRT ( 2. ) ** ( 7. / 4. ) / SQRT ( 1 5. ) * ( - 1 + EXP ( imag / 2. * ( SQRT ( 3. ) * kx + 3. * ky ))) Hamiltonian ( 3 + TBA_DIM , 2 + ORBITALS + TBA_DIM ) = Hamiltonian ( 3 + TBA_DIM , 2 + ORBITALS + TBA_DIM ) + eta_p * V_pdp * SQRT ( 2. ) ** ( 7. / 4. ) / SQRT ( 1 5. ) * ( - 1 + EXP ( - imag / 2. * ( SQRT ( 3. ) * kx - 3. * ky ))) !Nambu space kx = - kx ky = - ky !Spin-up part Hamiltonian ( 1 + DIM_POSITIVE_K , 2 + ORBITALS + DIM_POSITIVE_K ) = Hamiltonian ( 1 + DIM_POSITIVE_K , 2 + ORBITALS + DIM_POSITIVE_K ) - CONJG ( eta_p * V_pdp * SQRT ( 2. ) ** ( 7. / 4. ) / SQRT ( 1 5. ) * ( - 2. * imag * EXP ( imag * 3. / 2. * ky ) * SIN ( SQRT ( 3. ) / 2. * kx ))) Hamiltonian ( 1 + DIM_POSITIVE_K , 3 + ORBITALS + DIM_POSITIVE_K ) = Hamiltonian ( 1 + DIM_POSITIVE_K , 3 + ORBITALS + DIM_POSITIVE_K ) - CONJG ( eta_p * V_pdp * SQRT ( 2. ) ** ( 7. / 4. ) / SQRT ( 1 5. ) * ( 1 - EXP ( imag / 2. * ( SQRT ( 3. ) * kx + 3. * ky )))) Hamiltonian ( 2 + DIM_POSITIVE_K , 1 + ORBITALS + DIM_POSITIVE_K ) = Hamiltonian ( 2 + DIM_POSITIVE_K , 1 + ORBITALS + DIM_POSITIVE_K ) - CONJG ( eta_p * V_pdp * SQRT ( 2. ) ** ( 7. / 4. ) / SQRT ( 1 5. ) * ( 2 * imag * EXP ( imag * 3. / 2. * ky ) * SIN ( SQRT ( 3. ) / 2. * kx ))) Hamiltonian ( 2 + DIM_POSITIVE_K , 3 + ORBITALS + DIM_POSITIVE_K ) = Hamiltonian ( 2 + DIM_POSITIVE_K , 3 + ORBITALS + DIM_POSITIVE_K ) - CONJG ( eta_p * V_pdp * SQRT ( 2. ) ** ( 7. / 4. ) / SQRT ( 1 5. ) * ( 1 - EXP ( - imag / 2. * ( SQRT ( 3. ) * kx - 3. * ky )))) Hamiltonian ( 3 + DIM_POSITIVE_K , 1 + ORBITALS + DIM_POSITIVE_K ) = Hamiltonian ( 3 + DIM_POSITIVE_K , 1 + ORBITALS + DIM_POSITIVE_K ) - CONJG ( eta_p * V_pdp * SQRT ( 2. ) ** ( 7. / 4. ) / SQRT ( 1 5. ) * ( - 1 + EXP ( imag / 2. * ( SQRT ( 3. ) * kx + 3. * ky )))) Hamiltonian ( 3 + DIM_POSITIVE_K , 2 + ORBITALS + DIM_POSITIVE_K ) = Hamiltonian ( 3 + DIM_POSITIVE_K , 2 + ORBITALS + DIM_POSITIVE_K ) - CONJG ( eta_p * V_pdp * SQRT ( 2. ) ** ( 7. / 4. ) / SQRT ( 1 5. ) * ( - 1 + EXP ( - imag / 2. * ( SQRT ( 3. ) * kx - 3. * ky )))) !Spin-down part Hamiltonian ( 1 + TBA_DIM + DIM_POSITIVE_K , 2 + ORBITALS + TBA_DIM + DIM_POSITIVE_K ) = Hamiltonian ( 1 + TBA_DIM + DIM_POSITIVE_K , 2 + ORBITALS + TBA_DIM + DIM_POSITIVE_K ) - CONJG ( eta_p * V_pdp * SQRT ( 2. ) ** ( 7. / 4. ) / SQRT ( 1 5. ) * ( - 2. * imag * EXP ( imag * 3. / 2. * ky ) * SIN ( SQRT ( 3. ) / 2. * kx ))) Hamiltonian ( 1 + TBA_DIM + DIM_POSITIVE_K , 3 + ORBITALS + TBA_DIM + DIM_POSITIVE_K ) = Hamiltonian ( 1 + TBA_DIM + DIM_POSITIVE_K , 3 + ORBITALS + TBA_DIM + DIM_POSITIVE_K ) - CONJG ( eta_p * V_pdp * SQRT ( 2. ) ** ( 7. / 4. ) / SQRT ( 1 5. ) * ( 1 - EXP ( imag / 2. * ( SQRT ( 3. ) * kx + 3. * ky )))) Hamiltonian ( 2 + TBA_DIM + DIM_POSITIVE_K , 1 + ORBITALS + TBA_DIM + DIM_POSITIVE_K ) = Hamiltonian ( 2 + TBA_DIM + DIM_POSITIVE_K , 1 + ORBITALS + TBA_DIM + DIM_POSITIVE_K ) - CONJG ( eta_p * V_pdp * SQRT ( 2. ) ** ( 7. / 4. ) / SQRT ( 1 5. ) * ( 2 * imag * EXP ( imag * 3. / 2. * ky ) * SIN ( SQRT ( 3. ) / 2. * kx ))) Hamiltonian ( 2 + TBA_DIM + DIM_POSITIVE_K , 3 + ORBITALS + TBA_DIM + DIM_POSITIVE_K ) = Hamiltonian ( 2 + TBA_DIM + DIM_POSITIVE_K , 3 + ORBITALS + TBA_DIM + DIM_POSITIVE_K ) - CONJG ( eta_p * V_pdp * SQRT ( 2. ) ** ( 7. / 4. ) / SQRT ( 1 5. ) * ( 1 - EXP ( - imag / 2. * ( SQRT ( 3. ) * kx - 3. * ky )))) Hamiltonian ( 3 + TBA_DIM + DIM_POSITIVE_K , 1 + ORBITALS + TBA_DIM + DIM_POSITIVE_K ) = Hamiltonian ( 3 + TBA_DIM + DIM_POSITIVE_K , 1 + ORBITALS + TBA_DIM + DIM_POSITIVE_K ) - CONJG ( eta_p * V_pdp * SQRT ( 2. ) ** ( 7. / 4. ) / SQRT ( 1 5. ) * ( - 1 + EXP ( imag / 2. * ( SQRT ( 3. ) * kx + 3. * ky )))) Hamiltonian ( 3 + TBA_DIM + DIM_POSITIVE_K , 2 + ORBITALS + TBA_DIM + DIM_POSITIVE_K ) = Hamiltonian ( 3 + TBA_DIM + DIM_POSITIVE_K , 2 + ORBITALS + TBA_DIM + DIM_POSITIVE_K ) - CONJG ( eta_p * V_pdp * SQRT ( 2. ) ** ( 7. / 4. ) / SQRT ( 1 5. ) * ( - 1 + EXP ( - imag / 2. * ( SQRT ( 3. ) * kx - 3. * ky )))) kx = - kx ky = - ky END SUBROUTINE COMPUTE_TI1_TI2 SUBROUTINE COMPUTE_H_PI ( Hamiltonian , kx , ky ) IMPLICIT NONE COMPLEX * 16 , INTENT ( INOUT ) :: Hamiltonian ( DIM , DIM ) REAL * 8 , INTENT ( INOUT ) :: kx , ky REAL * 8 :: k1 , k2 , k3 k1 = - SQRT ( 3. ) / 2. * kx + 3. / 2. * ky k2 = - SQRT ( 3. ) / 2. * kx - 3. / 2. * ky k3 = SQRT ( 3. ) * kx !Spin up, Ti1 Hamiltonian ( 1 , 2 ) = Hamiltonian ( 1 , 2 ) - eta_p * 2 * imag * V_pdp / SQRT ( 1 5. ) * ( SIN ( k1 ) + SIN ( k2 ) + 2 * SIN ( k3 )) Hamiltonian ( 1 , 3 ) = Hamiltonian ( 1 , 3 ) + eta_p * 2 * imag * V_pdp / SQRT ( 1 5. ) * ( SIN ( k1 ) + 2 * SIN ( k2 ) + SIN ( k3 )) Hamiltonian ( 2 , 3 ) = Hamiltonian ( 2 , 3 ) - eta_p * 2 * imag * V_pdp / SQRT ( 1 5. ) * ( 2 * SIN ( k1 ) + SIN ( k2 ) + SIN ( k3 )) !Spin up, Ti2 Hamiltonian ( 1 + ORBITALS , 2 + ORBITALS ) = Hamiltonian ( 1 + ORBITALS , 2 + ORBITALS ) - eta_p * 2 * imag * V_pdp / SQRT ( 1 5. ) * ( SIN ( k1 ) + SIN ( k2 ) + 2 * SIN ( k3 )) Hamiltonian ( 1 + ORBITALS , 3 + ORBITALS ) = Hamiltonian ( 1 + ORBITALS , 3 + ORBITALS ) + eta_p * 2 * imag * V_pdp / SQRT ( 1 5. ) * ( SIN ( k1 ) + 2 * SIN ( k2 ) + SIN ( k3 )) Hamiltonian ( 2 + ORBITALS , 3 + ORBITALS ) = Hamiltonian ( 2 + ORBITALS , 3 + ORBITALS ) - eta_p * 2 * imag * V_pdp / SQRT ( 1 5. ) * ( 2 * SIN ( k1 ) + SIN ( k2 ) + SIN ( k3 )) !Spin down, Ti1 Hamiltonian ( 1 + TBA_DIM , 2 + TBA_DIM ) = Hamiltonian ( 1 + TBA_DIM , 2 + TBA_DIM ) - eta_p * 2 * imag * V_pdp / SQRT ( 1 5. ) * ( SIN ( k1 ) + SIN ( k2 ) + 2 * SIN ( k3 )) Hamiltonian ( 1 + TBA_DIM , 3 + TBA_DIM ) = Hamiltonian ( 1 + TBA_DIM , 3 + TBA_DIM ) + eta_p * 2 * imag * V_pdp / SQRT ( 1 5. ) * ( SIN ( k1 ) + 2 * SIN ( k2 ) + SIN ( k3 )) Hamiltonian ( 2 + TBA_DIM , 3 + TBA_DIM ) = Hamiltonian ( 2 + TBA_DIM , 3 + TBA_DIM ) - eta_p * 2 * imag * V_pdp / SQRT ( 1 5. ) * ( 2 * SIN ( k1 ) + SIN ( k2 ) + SIN ( k3 )) !Spin down, Ti2 Hamiltonian ( 1 + ORBITALS + TBA_DIM , 2 + ORBITALS + TBA_DIM ) = Hamiltonian ( 1 + ORBITALS + TBA_DIM , 2 + ORBITALS + TBA_DIM ) - eta_p * 2 * imag * V_pdp / SQRT ( 1 5. ) * ( SIN ( k1 ) + SIN ( k2 ) + 2 * SIN ( k3 )) Hamiltonian ( 1 + ORBITALS + TBA_DIM , 3 + ORBITALS + TBA_DIM ) = Hamiltonian ( 1 + ORBITALS + TBA_DIM , 3 + ORBITALS + TBA_DIM ) + eta_p * 2 * imag * V_pdp / SQRT ( 1 5. ) * ( SIN ( k1 ) + 2 * SIN ( k2 ) + SIN ( k3 )) Hamiltonian ( 2 + ORBITALS + TBA_DIM , 3 + ORBITALS + TBA_DIM ) = Hamiltonian ( 2 + ORBITALS + TBA_DIM , 3 + ORBITALS + TBA_DIM ) - eta_p * 2 * imag * V_pdp / SQRT ( 1 5. ) * ( 2 * SIN ( k1 ) + SIN ( k2 ) + SIN ( k3 )) !Nambu space k1 = - k1 k2 = - k2 k3 = - k3 !Spin up, Ti1 Hamiltonian ( 1 + DIM_POSITIVE_K , 2 + DIM_POSITIVE_K ) = Hamiltonian ( 1 + DIM_POSITIVE_K , 2 + DIM_POSITIVE_K ) + CONJG ( eta_p * 2 * imag * V_pdp / SQRT ( 1 5. ) * ( SIN ( k1 ) + SIN ( k2 ) + 2 * SIN ( k3 ))) Hamiltonian ( 1 + DIM_POSITIVE_K , 3 + DIM_POSITIVE_K ) = Hamiltonian ( 1 + DIM_POSITIVE_K , 3 + DIM_POSITIVE_K ) - CONJG ( eta_p * 2 * imag * V_pdp / SQRT ( 1 5. ) * ( SIN ( k1 ) + 2 * SIN ( k2 ) + SIN ( k3 ))) Hamiltonian ( 2 + DIM_POSITIVE_K , 3 + DIM_POSITIVE_K ) = Hamiltonian ( 2 + DIM_POSITIVE_K , 3 + DIM_POSITIVE_K ) + CONJG ( eta_p * 2 * imag * V_pdp / SQRT ( 1 5. ) * ( 2 * SIN ( k1 ) + SIN ( k2 ) + SIN ( k3 ))) !Spin up, Ti2 Hamiltonian ( 1 + ORBITALS + DIM_POSITIVE_K , 2 + ORBITALS + DIM_POSITIVE_K ) = Hamiltonian ( 1 + ORBITALS + DIM_POSITIVE_K , 2 + ORBITALS + DIM_POSITIVE_K ) + CONJG ( eta_p * 2 * imag * V_pdp / SQRT ( 1 5. ) * ( SIN ( k1 ) + SIN ( k2 ) + 2 * SIN ( k3 ))) Hamiltonian ( 1 + ORBITALS + DIM_POSITIVE_K , 3 + ORBITALS + DIM_POSITIVE_K ) = Hamiltonian ( 1 + ORBITALS + DIM_POSITIVE_K , 3 + ORBITALS + DIM_POSITIVE_K ) - CONJG ( eta_p * 2 * imag * V_pdp / SQRT ( 1 5. ) * ( SIN ( k1 ) + 2 * SIN ( k2 ) + SIN ( k3 ))) Hamiltonian ( 2 + ORBITALS + DIM_POSITIVE_K , 3 + ORBITALS + DIM_POSITIVE_K ) = Hamiltonian ( 2 + ORBITALS + DIM_POSITIVE_K , 3 + ORBITALS + DIM_POSITIVE_K ) + CONJG ( eta_p * 2 * imag * V_pdp / SQRT ( 1 5. ) * ( 2 * SIN ( k1 ) + SIN ( k2 ) + SIN ( k3 ))) !Spin down, Ti1 Hamiltonian ( 1 + TBA_DIM + DIM_POSITIVE_K , 2 + TBA_DIM + DIM_POSITIVE_K ) = Hamiltonian ( 1 + TBA_DIM + DIM_POSITIVE_K , 2 + TBA_DIM + DIM_POSITIVE_K ) + CONJG ( eta_p * 2 * imag * V_pdp / SQRT ( 1 5. ) * ( SIN ( k1 ) + SIN ( k2 ) + 2 * SIN ( k3 ))) Hamiltonian ( 1 + TBA_DIM + DIM_POSITIVE_K , 3 + TBA_DIM + DIM_POSITIVE_K ) = Hamiltonian ( 1 + TBA_DIM + DIM_POSITIVE_K , 3 + TBA_DIM + DIM_POSITIVE_K ) - CONJG ( eta_p * 2 * imag * V_pdp / SQRT ( 1 5. ) * ( SIN ( k1 ) + 2 * SIN ( k2 ) + SIN ( k3 ))) Hamiltonian ( 2 + TBA_DIM + DIM_POSITIVE_K , 3 + TBA_DIM + DIM_POSITIVE_K ) = Hamiltonian ( 2 + TBA_DIM + DIM_POSITIVE_K , 3 + TBA_DIM + DIM_POSITIVE_K ) + CONJG ( eta_p * 2 * imag * V_pdp / SQRT ( 1 5. ) * ( 2 * SIN ( k1 ) + SIN ( k2 ) + SIN ( k3 ))) !Spin down, Ti2 Hamiltonian ( 1 + ORBITALS + TBA_DIM + DIM_POSITIVE_K , 2 + ORBITALS + TBA_DIM + DIM_POSITIVE_K ) = Hamiltonian ( 1 + ORBITALS + TBA_DIM + DIM_POSITIVE_K , 2 + ORBITALS + TBA_DIM + DIM_POSITIVE_K ) + CONJG ( eta_p * 2 * imag * V_pdp / SQRT ( 1 5. ) * ( SIN ( k1 ) + SIN ( k2 ) + 2 * SIN ( k3 ))) Hamiltonian ( 1 + ORBITALS + TBA_DIM + DIM_POSITIVE_K , 3 + ORBITALS + TBA_DIM + DIM_POSITIVE_K ) = Hamiltonian ( 1 + ORBITALS + TBA_DIM + DIM_POSITIVE_K , 3 + ORBITALS + TBA_DIM + DIM_POSITIVE_K ) - CONJG ( eta_p * 2 * imag * V_pdp / SQRT ( 1 5. ) * ( SIN ( k1 ) + 2 * SIN ( k2 ) + SIN ( k3 ))) Hamiltonian ( 2 + ORBITALS + TBA_DIM + DIM_POSITIVE_K , 3 + ORBITALS + TBA_DIM + DIM_POSITIVE_K ) = Hamiltonian ( 2 + ORBITALS + TBA_DIM + DIM_POSITIVE_K , 3 + ORBITALS + TBA_DIM + DIM_POSITIVE_K ) + CONJG ( eta_p * 2 * imag * V_pdp / SQRT ( 1 5. ) * ( 2 * SIN ( k1 ) + SIN ( k2 ) + SIN ( k3 ))) END SUBROUTINE COMPUTE_H_PI SUBROUTINE COMPUTE_H_SIGMA ( Hamiltonian , kx , ky ) IMPLICIT NONE COMPLEX * 16 , INTENT ( INOUT ) :: Hamiltonian ( DIM , DIM ) REAL * 8 , INTENT ( INOUT ) :: kx , ky REAL * 8 :: k1 , k2 , k3 k1 = - SQRT ( 3. ) / 2. * kx + 3. / 2. * ky k2 = - SQRT ( 3. ) / 2. * kx - 3. / 2. * ky k3 = SQRT ( 3. ) * kx !Spin up, Ti1 Hamiltonian ( 1 , 2 ) = Hamiltonian ( 1 , 2 ) + eta_p * 2 * imag * SQRT ( 3. ) * V_pds / SQRT ( 1 5. ) * ( SIN ( k1 ) + SIN ( k2 )) Hamiltonian ( 1 , 3 ) = Hamiltonian ( 1 , 3 ) - eta_p * 2 * imag * SQRT ( 3. ) * V_pds / SQRT ( 1 5. ) * ( SIN ( k1 ) + SIN ( k2 )) Hamiltonian ( 2 , 3 ) = Hamiltonian ( 2 , 3 ) + eta_p * 2 * imag * SQRT ( 3. ) * V_pds / SQRT ( 1 5. ) * ( SIN ( k2 ) + SIN ( k3 )) !Spin up, Ti2 Hamiltonian ( 1 + ORBITALS , 2 + ORBITALS ) = Hamiltonian ( 1 + ORBITALS , 2 + ORBITALS ) + eta_p * 2 * imag * SQRT ( 3. ) * V_pds / SQRT ( 1 5. ) * ( SIN ( k1 ) + SIN ( k2 )) Hamiltonian ( 1 + ORBITALS , 3 + ORBITALS ) = Hamiltonian ( 1 + ORBITALS , 3 + ORBITALS ) - eta_p * 2 * imag * SQRT ( 3. ) * V_pds / SQRT ( 1 5. ) * ( SIN ( k1 ) + SIN ( k2 )) Hamiltonian ( 2 + ORBITALS , 3 + ORBITALS ) = Hamiltonian ( 2 + ORBITALS , 3 + ORBITALS ) + eta_p * 2 * imag * SQRT ( 3. ) * V_pds / SQRT ( 1 5. ) * ( SIN ( k2 ) + SIN ( k3 )) !Spin down, Ti1 Hamiltonian ( 1 + TBA_DIM , 2 + TBA_DIM ) = Hamiltonian ( 1 + TBA_DIM , 2 + TBA_DIM ) + eta_p * 2 * imag * SQRT ( 3. ) * V_pds / SQRT ( 1 5. ) * ( SIN ( k1 ) + SIN ( k2 )) Hamiltonian ( 1 + TBA_DIM , 3 + TBA_DIM ) = Hamiltonian ( 1 + TBA_DIM , 3 + TBA_DIM ) - eta_p * 2 * imag * SQRT ( 3. ) * V_pds / SQRT ( 1 5. ) * ( SIN ( k1 ) + SIN ( k2 )) Hamiltonian ( 2 + TBA_DIM , 3 + TBA_DIM ) = Hamiltonian ( 2 + TBA_DIM , 3 + TBA_DIM ) + eta_p * 2 * imag * SQRT ( 3. ) * V_pds / SQRT ( 1 5. ) * ( SIN ( k2 ) + SIN ( k3 )) !Spin down, Ti2 Hamiltonian ( 1 + ORBITALS + TBA_DIM , 2 + ORBITALS + TBA_DIM ) = Hamiltonian ( 1 + ORBITALS + TBA_DIM , 2 + ORBITALS + TBA_DIM ) + eta_p * 2 * imag * SQRT ( 3. ) * V_pds / SQRT ( 1 5. ) * ( SIN ( k1 ) + SIN ( k2 )) Hamiltonian ( 1 + ORBITALS + TBA_DIM , 3 + ORBITALS + TBA_DIM ) = Hamiltonian ( 1 + ORBITALS + TBA_DIM , 3 + ORBITALS + TBA_DIM ) - eta_p * 2 * imag * SQRT ( 3. ) * V_pds / SQRT ( 1 5. ) * ( SIN ( k1 ) + SIN ( k2 )) Hamiltonian ( 2 + ORBITALS + TBA_DIM , 3 + ORBITALS + TBA_DIM ) = Hamiltonian ( 2 + ORBITALS + TBA_DIM , 3 + ORBITALS + TBA_DIM ) + eta_p * 2 * imag * SQRT ( 3. ) * V_pds / SQRT ( 1 5. ) * ( SIN ( k2 ) + SIN ( k3 )) !Nambu space k1 = - k1 k2 = - k2 k3 = - k3 !Spin up, Ti1 Hamiltonian ( 1 + DIM_POSITIVE_K , 2 + DIM_POSITIVE_K ) = Hamiltonian ( 1 + DIM_POSITIVE_K , 2 + DIM_POSITIVE_K ) - CONJG ( eta_p * 2 * imag * SQRT ( 3. ) * V_pds / SQRT ( 1 5. ) * ( SIN ( k1 ) + SIN ( k2 ))) Hamiltonian ( 1 + DIM_POSITIVE_K , 3 + DIM_POSITIVE_K ) = Hamiltonian ( 1 + DIM_POSITIVE_K , 3 + DIM_POSITIVE_K ) + CONJG ( eta_p * 2 * imag * SQRT ( 3. ) * V_pds / SQRT ( 1 5. ) * ( SIN ( k1 ) + SIN ( k2 ))) Hamiltonian ( 2 + DIM_POSITIVE_K , 3 + DIM_POSITIVE_K ) = Hamiltonian ( 2 + DIM_POSITIVE_K , 3 + DIM_POSITIVE_K ) - CONJG ( eta_p * 2 * imag * SQRT ( 3. ) * V_pds / SQRT ( 1 5. ) * ( SIN ( k2 ) + SIN ( k3 ))) !Spin up, Ti2 Hamiltonian ( 1 + ORBITALS + DIM_POSITIVE_K , 2 + ORBITALS + DIM_POSITIVE_K ) = Hamiltonian ( 1 + ORBITALS + DIM_POSITIVE_K , 2 + ORBITALS + DIM_POSITIVE_K ) - CONJG ( eta_p * 2 * imag * SQRT ( 3. ) * V_pds / SQRT ( 1 5. ) * ( SIN ( k1 ) + SIN ( k2 ))) Hamiltonian ( 1 + ORBITALS + DIM_POSITIVE_K , 3 + ORBITALS + DIM_POSITIVE_K ) = Hamiltonian ( 1 + ORBITALS + DIM_POSITIVE_K , 3 + ORBITALS + DIM_POSITIVE_K ) + CONJG ( eta_p * 2 * imag * SQRT ( 3. ) * V_pds / SQRT ( 1 5. ) * ( SIN ( k1 ) + SIN ( k2 ))) Hamiltonian ( 2 + ORBITALS + DIM_POSITIVE_K , 3 + ORBITALS + DIM_POSITIVE_K ) = Hamiltonian ( 2 + ORBITALS + DIM_POSITIVE_K , 3 + ORBITALS + DIM_POSITIVE_K ) - CONJG ( eta_p * 2 * imag * SQRT ( 3. ) * V_pds / SQRT ( 1 5. ) * ( SIN ( k2 ) + SIN ( k3 ))) !Spin down, Ti1 Hamiltonian ( 1 + TBA_DIM + DIM_POSITIVE_K , 2 + TBA_DIM + DIM_POSITIVE_K ) = Hamiltonian ( 1 + TBA_DIM + DIM_POSITIVE_K , 2 + TBA_DIM + DIM_POSITIVE_K ) - CONJG ( eta_p * 2 * imag * SQRT ( 3. ) * V_pds / SQRT ( 1 5. ) * ( SIN ( k1 ) + SIN ( k2 ))) Hamiltonian ( 1 + TBA_DIM + DIM_POSITIVE_K , 3 + TBA_DIM + DIM_POSITIVE_K ) = Hamiltonian ( 1 + TBA_DIM + DIM_POSITIVE_K , 3 + TBA_DIM + DIM_POSITIVE_K ) + CONJG ( eta_p * 2 * imag * SQRT ( 3. ) * V_pds / SQRT ( 1 5. ) * ( SIN ( k1 ) + SIN ( k2 ))) Hamiltonian ( 2 + TBA_DIM + DIM_POSITIVE_K , 3 + TBA_DIM + DIM_POSITIVE_K ) = Hamiltonian ( 2 + TBA_DIM + DIM_POSITIVE_K , 3 + TBA_DIM + DIM_POSITIVE_K ) - CONJG ( eta_p * 2 * imag * SQRT ( 3. ) * V_pds / SQRT ( 1 5. ) * ( SIN ( k2 ) + SIN ( k3 ))) !Spin down, Ti2 Hamiltonian ( 1 + ORBITALS + TBA_DIM + DIM_POSITIVE_K , 2 + ORBITALS + TBA_DIM + DIM_POSITIVE_K ) = Hamiltonian ( 1 + ORBITALS + TBA_DIM + DIM_POSITIVE_K , 2 + ORBITALS + TBA_DIM + DIM_POSITIVE_K ) - CONJG ( eta_p * 2 * imag * SQRT ( 3. ) * V_pds / SQRT ( 1 5. ) * ( SIN ( k1 ) + SIN ( k2 ))) Hamiltonian ( 1 + ORBITALS + TBA_DIM + DIM_POSITIVE_K , 3 + ORBITALS + TBA_DIM + DIM_POSITIVE_K ) = Hamiltonian ( 1 + ORBITALS + TBA_DIM + DIM_POSITIVE_K , 3 + ORBITALS + TBA_DIM + DIM_POSITIVE_K ) + CONJG ( eta_p * 2 * imag * SQRT ( 3. ) * V_pds / SQRT ( 1 5. ) * ( SIN ( k1 ) + SIN ( k2 ))) Hamiltonian ( 2 + ORBITALS + TBA_DIM + DIM_POSITIVE_K , 3 + ORBITALS + TBA_DIM + DIM_POSITIVE_K ) = Hamiltonian ( 2 + ORBITALS + TBA_DIM + DIM_POSITIVE_K , 3 + ORBITALS + TBA_DIM + DIM_POSITIVE_K ) - CONJG ( eta_p * 2 * imag * SQRT ( 3. ) * V_pds / SQRT ( 1 5. ) * ( SIN ( k2 ) + SIN ( k3 ))) END SUBROUTINE COMPUTE_H_SIGMA SUBROUTINE COMPUTE_SC ( Hamiltonian , kx , ky , Gamma_SC ) IMPLICIT NONE COMPLEX * 16 , INTENT ( INOUT ) :: Hamiltonian ( DIM , DIM ) COMPLEX * 16 , INTENT ( IN ) :: Gamma_SC ( ORBITALS , N_ALL_NEIGHBOURS , 2 , SUBLATTICES ) REAL * 8 , INTENT ( IN ) :: kx , ky INTEGER * 4 :: orb , lat , spin !Nearest neighbours pairing DO orb = 1 , ORBITALS !Up - down Ti1 - Ti2 coupling Hamiltonian ( orb , orb + ORBITALS + DIM_POSITIVE_K + TBA_DIM ) = Hamiltonian ( orb , orb + ORBITALS + DIM_POSITIVE_K + TBA_DIM ) + & & Gamma_SC ( orb , 1 , 2 , 2 ) * pairing_1 ( ky ) + Gamma_SC ( orb , 2 , 2 , 2 ) * pairing_2 ( kx , ky ) + Gamma_SC ( orb , 3 , 2 , 2 ) * pairing_3 ( kx , ky ) !Up - down Ti2 - Ti1 coupling Hamiltonian ( orb + ORBITALS , orb + DIM_POSITIVE_K + TBA_DIM ) = Hamiltonian ( orb + ORBITALS , orb + DIM_POSITIVE_K + TBA_DIM ) + & & Gamma_SC ( orb , 1 , 2 , 1 ) * CONJG ( pairing_1 ( ky )) + Gamma_SC ( orb , 2 , 2 , 1 ) * CONJG ( pairing_2 ( kx , ky )) + Gamma_SC ( orb , 3 , 2 , 1 ) * CONJG ( pairing_3 ( kx , ky )) !Down - up Ti1 - Ti2 coupling Hamiltonian ( orb + TBA_DIM , orb + ORBITALS + DIM_POSITIVE_K ) = Hamiltonian ( orb + TBA_DIM , orb + ORBITALS + DIM_POSITIVE_K ) + & & Gamma_SC ( orb , 1 , 1 , 2 ) * pairing_1 ( ky ) + Gamma_SC ( orb , 2 , 1 , 2 ) * pairing_2 ( kx , ky ) + Gamma_SC ( orb , 3 , 1 , 2 ) * pairing_3 ( kx , ky ) !Down - up Ti2 - Ti1 coupling Hamiltonian ( orb + ORBITALS + TBA_DIM , orb + DIM_POSITIVE_K ) = Hamiltonian ( orb + ORBITALS + TBA_DIM , orb + DIM_POSITIVE_K ) + & & Gamma_SC ( orb , 1 , 1 , 1 ) * CONJG ( pairing_1 ( ky )) + Gamma_SC ( orb , 2 , 1 , 1 ) * CONJG ( pairing_2 ( kx , ky )) + Gamma_SC ( orb , 3 , 1 , 1 ) * CONJG ( pairing_3 ( kx , ky )) END DO !Next nearest neighbours pairing DO orb = 1 , ORBITALS DO lat = 0 , SUBLATTICES - 1 DO spin = 0 , 1 Hamiltonian ( orb + lat * ORBITALS + spin * TBA_DIM , orb + lat * ORBITALS + MOD ( spin + 1 , 2 ) * TBA_DIM + DIM_POSITIVE_K ) = Hamiltonian ( orb + lat * ORBITALS + spin * TBA_DIM , orb + lat * ORBITALS + MOD ( spin + 1 , 2 ) * TBA_DIM + DIM_POSITIVE_K ) + & & Gamma_SC ( orb , N_NEIGHBOURS + 1 , MOD ( spin + 1 , 2 ) + 1 , lat + 1 ) * CONJG ( pairing_nnn_1 ( kx )) + & & Gamma_SC ( orb , N_NEIGHBOURS + 2 , MOD ( spin + 1 , 2 ) + 1 , lat + 1 ) * CONJG ( pairing_nnn_2 ( kx , ky )) + & & Gamma_SC ( orb , N_NEIGHBOURS + 3 , MOD ( spin + 1 , 2 ) + 1 , lat + 1 ) * CONJG ( pairing_nnn_3 ( kx , ky )) + & & Gamma_SC ( orb , N_NEIGHBOURS + 4 , MOD ( spin + 1 , 2 ) + 1 , lat + 1 ) * CONJG ( pairing_nnn_4 ( kx )) + & & Gamma_SC ( orb , N_NEIGHBOURS + 5 , MOD ( spin + 1 , 2 ) + 1 , lat + 1 ) * CONJG ( pairing_nnn_5 ( kx , ky )) + & & Gamma_SC ( orb , N_NEIGHBOURS + 6 , MOD ( spin + 1 , 2 ) + 1 , lat + 1 ) * CONJG ( pairing_nnn_6 ( kx , ky )) END DO END DO END DO END SUBROUTINE COMPUTE_SC SUBROUTINE COMPUTE_HUBBARD ( Hamiltonian , Charge_dens ) IMPLICIT NONE COMPLEX * 16 , INTENT ( INOUT ) :: Hamiltonian ( DIM , DIM ) REAL * 8 , INTENT ( IN ) :: Charge_dens ( DIM_POSITIVE_K ) INTEGER * 4 :: orb , lat , orb_prime , spin DO spin = 0 , 1 DO lat = 0 , SUBLATTICES - 1 DO orb = 1 , ORBITALS Hamiltonian ( spin * TBA_DIM + lat * ORBITALS + orb , spin * TBA_DIM + lat * ORBITALS + orb ) = Hamiltonian ( spin * TBA_DIM + lat * ORBITALS + orb , spin * TBA_DIM + lat * ORBITALS + orb ) + & & U_HUB * Charge_dens ( MOD ( spin + 1 , 2 ) * TBA_DIM + lat * ORBITALS + orb ) !Modulo should give opposite spin DO orb_prime = 1 , ORBITALS IF ( orb . NE . orb_prime ) THEN Hamiltonian ( spin * TBA_DIM + lat * ORBITALS + orb , spin * TBA_DIM + lat * ORBITALS + orb ) = Hamiltonian ( spin * TBA_DIM + lat * ORBITALS + orb , spin * TBA_DIM + lat * ORBITALS + orb ) + & & V_HUB * ( Charge_dens ( lat * ORBITALS + orb_prime ) + Charge_dens ( TBA_DIM + lat * ORBITALS + orb_prime )) !total charge dens in orbital END IF END DO END DO END DO END DO !Nambu space DO spin = 0 , 1 DO lat = 0 , SUBLATTICES - 1 DO orb = 1 , ORBITALS Hamiltonian ( DIM_POSITIVE_K + spin * TBA_DIM + lat * ORBITALS + orb , DIM_POSITIVE_K + spin * TBA_DIM + lat * ORBITALS + orb ) = Hamiltonian ( DIM_POSITIVE_K + spin * TBA_DIM + lat * ORBITALS + orb , DIM_POSITIVE_K + spin * TBA_DIM + lat * ORBITALS + orb ) - & & U_HUB * Charge_dens ( MOD ( spin + 1 , 2 ) * TBA_DIM + lat * ORBITALS + orb ) !Modulo should give opposite spin DO orb_prime = 1 , ORBITALS IF ( orb . NE . orb_prime ) THEN Hamiltonian ( DIM_POSITIVE_K + spin * TBA_DIM + lat * ORBITALS + orb , DIM_POSITIVE_K + spin * TBA_DIM + lat * ORBITALS + orb ) = Hamiltonian ( DIM_POSITIVE_K + spin * TBA_DIM + lat * ORBITALS + orb , DIM_POSITIVE_K + spin * TBA_DIM + lat * ORBITALS + orb ) - & & V_HUB * ( Charge_dens ( lat * ORBITALS + orb_prime ) + Charge_dens ( TBA_DIM + lat * ORBITALS + orb_prime )) !total charge dens in orbital END IF END DO END DO END DO END DO END SUBROUTINE COMPUTE_HUBBARD SUBROUTINE COMPUTE_ZEEMAN ( Bfield , Hamiltonian ) REAL * 8 , INTENT ( IN ) :: Bfield ( 3 ) COMPLEX * 16 , INTENT ( INOUT ) :: Hamiltonian ( DIM , DIM ) REAL * 8 , PARAMETER :: gFactor = 3.0d0 REAL * 8 , PARAMETER :: muB = 0.5 INTEGER * 4 :: i DO i = 1 , TBA_DIM !Electrons Hamiltonian ( i , i ) = Hamiltonian ( i , i ) + 0.5d0 * muB * gFactor * Bfield ( 3 ) Hamiltonian ( TBA_DIM + i , TBA_DIM + i ) = Hamiltonian ( TBA_DIM + i , TBA_DIM + i ) - 0.5d0 * muB * gFactor * Bfield ( 3 ) !Holes Hamiltonian ( 2 * TBA_DIM + i , 2 * TBA_DIM + i ) = Hamiltonian ( 2 * TBA_DIM + i , 2 * TBA_DIM + i ) - 0.5d0 * muB * gFactor * Bfield ( 3 ) Hamiltonian ( 3 * TBA_DIM + i , 3 * TBA_DIM + i ) = Hamiltonian ( 3 * TBA_DIM + i , 3 * TBA_DIM + i ) + 0.5d0 * muB * gFactor * Bfield ( 3 ) END DO END SUBROUTINE COMPUTE_ZEEMAN !################ ADDITIONAL HAMILTONIANS FOR TESTING ######################## SUBROUTINE DIAGONAL_TBA ( Hamiltonian , kx , ky ) IMPLICIT NONE COMPLEX * 16 , INTENT ( INOUT ) :: Hamiltonian ( DIM , DIM ) REAL * 8 , INTENT ( INOUT ) :: kx , ky INTEGER * 4 :: i DO i = 1 , DIM_POSITIVE_K Hamiltonian ( i , i ) = Hamiltonian ( i , i ) + ( DCOS ( kx ) + DCOS ( ky )) END DO !Nambu space kx = - kx ky = - ky DO i = DIM_POSITIVE_K + 1 , DIM Hamiltonian ( i , i ) = Hamiltonian ( i , i ) - ( DCOS ( kx ) + DCOS ( ky )) END DO kx = - kx ky = - ky END SUBROUTINE END MODULE mod_hamiltonians","tags":"","loc":"sourcefile/mod_hamiltonians.f90.html"},{"title":"mod_reader.f90 – Fortran Program","text":"Source Code MODULE mod_reader USE mod_parameters IMPLICIT NONE SAVE !Default values, overwritten in get_input !Physical parameters REAL * 8 :: T = 0. REAL * 8 :: t_D = 0. REAL * 8 :: t_I = 0. REAL * 8 :: lambda_SOC = 0. REAL * 8 :: DELTA_TRI = 0. REAL * 8 :: v = 0. REAL * 8 :: V_pdp = 0. REAL * 8 :: V_pds = 0. REAL * 8 :: J_SC = 0. REAL * 8 :: J_SC_PRIME = 0. REAL * 8 :: J_SC_NNN = 0. REAL * 8 :: J_SC_PRIME_NNN = 0. REAL * 8 :: U_HUB = 0. REAL * 8 :: V_HUB = 0. REAL * 8 :: E_Fermi = 0. !Discretization INTEGER * 4 :: k1_steps = 0 INTEGER * 4 :: k2_steps = 0 !Self-consistency REAL * 8 :: gamma_start = 0. REAL * 8 :: charge_start = 0. INTEGER * 4 :: max_sc_iter = 0 REAL * 8 :: sc_alpha = 0. REAL * 8 :: sc_alpha_adapt = 0. REAL * 8 :: gamma_eps_convergence = 0. REAL * 8 :: charge_eps_convergence = 0. !Romberg integration REAL * 8 :: romb_eps_x = 0. INTEGER * 4 :: interpolation_deg_x = 0 INTEGER * 4 :: max_grid_refinements_x = 0 REAL * 8 :: romb_eps_y = 0. INTEGER * 4 :: interpolation_deg_y = 0 INTEGER * 4 :: max_grid_refinements_y = 0 !Derived REAL * 8 eta_p REAL * 8 :: dk1 , dk2 , domega NAMELIST / physical_params / & & T , & & t_D , & & t_I , & & lambda_SOC , & & DELTA_TRI , & & v , & & V_pdp , & & V_pds , & & J_SC , & & J_SC_PRIME , & & J_SC_NNN , & & J_SC_PRIME_NNN , & & U_HUB , & & V_HUB , & & E_Fermi NAMELIST / discretization / & & k1_steps , & & k2_steps NAMELIST / self_consistency / & & gamma_start , & & charge_start , & & max_sc_iter , & & sc_alpha , & & sc_alpha_adapt , & & gamma_eps_convergence , & & charge_eps_convergence NAMELIST / romberg_integration / & & romb_eps_x , & & interpolation_deg_x , & & max_grid_refinements_x , & & romb_eps_y , & & interpolation_deg_y , & & max_grid_refinements_y CONTAINS SUBROUTINE GET_INPUT ( nmlfile ) IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: nmlfile OPEN ( unit = 9 , FILE = nmlfile , FORM = \"FORMATTED\" , ACTION = \"READ\" , STATUS = \"OLD\" ) !TODO: WRITE BETTER CHECKS!!!!!!!!!!!!!!!!!! READ ( 9 , NML = physical_params ) !Check input data IF ( T < 0 ) STOP \"Temperature in kelvins must be >= 0!\" !Change to atomic units t_D = t_D * meV2au t_I = t_I * meV2au lambda_SOC = lambda_SOC * meV2au DELTA_TRI = DELTA_TRI * meV2au v = v * meV2au V_pdp = V_pdp * meV2au V_pds = V_pds * meV2au J_SC = J_SC * meV2au J_SC_PRIME = J_SC_PRIME * meV2au J_SC_NNN = J_SC_NNN * meV2au J_SC_PRIME_NNN = J_SC_PRIME_NNN * meV2au U_HUB = U_HUB * meV2au V_HUB = V_HUB * meV2au E_Fermi = E_Fermi * meV2au READ ( 9 , NML = discretization ) IF (( k1_steps . LE . 0 ) . OR . ( k2_steps . LE . 0 )) STOP \"k_steps must be > 0\" READ ( 9 , NML = self_consistency ) IF ( charge_start . LT . 0 ) STOP \"charge_start must be >= 0\" IF ( max_sc_iter . LE . 0 ) STOP \"max_sc_iter must be > 0\" IF ( sc_alpha . LE . 0 ) STOP \"sc_alpha (mixing parameter) must be > 0\" IF (( sc_alpha_adapt . LE . 0 ) . OR . ( sc_alpha_adapt . GT . 1 )) STOP \"sc_alpha_adapt must be in interval [0,1]\" IF ( gamma_eps_convergence . LE . 0 ) STOP \"gamma_eps_convergence must be > 0\" IF ( charge_eps_convergence . LE . 0 ) STOP \"charge_eps_convergence must be > 0\" gamma_start = gamma_start * meV2au gamma_eps_convergence = gamma_eps_convergence * meV2au !Calculating derived values dk1 = K1_MAX / k1_steps dk2 = K2_MAX / k2_steps domega = ABS ( dk1 * dk2 * SIN ( 2 * PI / 3. )) / ( SIN ( 2 * PI / 3. ) * K1_MAX * K2_MAX ) eta_p = v * SQRT ( 3. ) / 3.905 * nm2au READ ( 9 , NML = romberg_integration ) IF ( romb_eps_x . LE . 0 ) STOP \"romb_eps_x must be > 0\" IF ( interpolation_deg_x . LE . 0 ) STOP \"interpolation_deg_x must be > 0\" IF ( max_grid_refinements_x . LE . 0 ) STOP \"max_grid_refinements_x must be > 0\" IF ( romb_eps_y . LE . 0 ) STOP \"romb_eps_y must be > 0\" IF ( interpolation_deg_y . LE . 0 ) STOP \"interpolation_deg_y must be > 0\" IF ( max_grid_refinements_y . LE . 0 ) STOP \"max_grid_refinements_y must be > 0\" CLOSE ( 9 ) END SUBROUTINE GET_INPUT SUBROUTINE GET_GAMMA_SC ( Gamma_SC , path ) CHARACTER ( LEN =* ), INTENT ( IN ) :: path COMPLEX * 16 , INTENT ( OUT ) :: Gamma_SC ( ORBITALS , N_ALL_NEIGHBOURS , 2 , SUBLATTICES ) INTEGER * 4 :: n , lat , orb , spin INTEGER * 4 :: n_read , lat_read , orb_read , spin_read REAL * 8 :: Gamma_re , Gamma_im CHARACTER ( LEN = 20 ) :: output_format output_format = '(4I5, 2E15.5)' OPEN ( unit = 9 , FILE = path , FORM = \"FORMATTED\" , ACTION = \"READ\" , STATUS = \"OLD\" ) READ ( 9 , * ) DO spin = 1 , 2 DO n = 1 , N_ALL_NEIGHBOURS DO lat = 1 , SUBLATTICES DO orb = 1 , ORBITALS READ ( 9 , output_format ) spin_read , n_read , lat_read , orb_read , Gamma_re , Gamma_im Gamma_SC ( orb_read , n_read , spin_read , lat_read ) = DCMPLX ( Gamma_re , Gamma_im ) END DO END DO READ ( 9 , * ) READ ( 9 , * ) END DO END DO CLOSE ( 9 ) END SUBROUTINE GET_GAMMA_SC SUBROUTINE GET_CHARGE_DENS ( Charge_dens , path ) CHARACTER ( LEN =* ), INTENT ( IN ) :: path REAL * 8 , INTENT ( OUT ) :: Charge_dens ( DIM_POSITIVE_K ) INTEGER * 4 :: spin , lat , orb , n CHARACTER ( LEN = 20 ) :: output_format output_format = '(3I5, 1E15.5)' OPEN ( unit = 9 , FILE = path , FORM = \"FORMATTED\" , ACTION = \"READ\" , STATUS = \"OLD\" ) READ ( 9 , * ) DO n = 1 , DIM_POSITIVE_K READ ( 9 , output_format ) spin , lat , orb , Charge_dens ( n ) END DO CLOSE ( 9 ) END SUBROUTINE GET_CHARGE_DENS END MODULE mod_reader","tags":"","loc":"sourcefile/mod_reader.f90.html"},{"title":"tests.f90 – Fortran Program","text":"Source Code PROGRAM Tests USE mod_hamiltonians USE mod_parameters USE mod_writers USE mod_reader IMPLICIT NONE COMPLEX * 16 , ALLOCATABLE :: Hamiltonian (:,:) REAL * 8 , ALLOCATABLE :: Charge_dens (:) ALLOCATE ( Hamiltonian ( DIM , DIM )) ALLOCATE ( Charge_dens ( DIM_POSITIVE_K )) Hamiltonian = DCMPLX ( 0. , 0. ) Charge_dens = 1. CALL GET_INPUT ( \"./test_input.nml\" ) CALL COMPUTE_HUBBARD ( Hamiltonian , Charge_dens ) CALL PRINT_HAMILTONIAN ( Hamiltonian / meV2au ) DEALLOCATE ( Hamiltonian ) DEALLOCATE ( Charge_dens ) END PROGRAM Tests","tags":"","loc":"sourcefile/tests.f90.html"},{"title":"mod_compute_hamiltonians.f90 – Fortran Program","text":"Source Code MODULE mod_compute_hamiltonians USE mod_parameters USE mod_utilities USE mod_hamiltonians USE mod_writers IMPLICIT NONE CONTAINS SUBROUTINE GET_LOCAL_CHARGE_AND_DELTA ( Hamiltonian_const , Gamma_SC , Charge_dens , k1 , k2 , Delta_local , Charge_dens_local ) COMPLEX * 16 , INTENT ( IN ) :: Hamiltonian_const ( DIM , DIM ) REAL * 8 , INTENT ( IN ) :: k1 , k2 COMPLEX * 16 , INTENT ( IN ) :: Gamma_SC ( ORBITALS , N_ALL_NEIGHBOURS , 2 , SUBLATTICES ) REAL * 8 , INTENT ( IN ) :: Charge_dens ( DIM_POSITIVE_K ) COMPLEX * 16 , INTENT ( OUT ) :: Delta_local ( ORBITALS , N_ALL_NEIGHBOURS , 2 , SUBLATTICES ) REAL * 8 , INTENT ( OUT ) :: Charge_dens_local ( DIM_POSITIVE_K ) COMPLEX * 16 :: Hamiltonian ( DIM , DIM ) COMPLEX * 16 :: U_transformation ( DIM , DIM ) REAL * 8 :: Energies ( DIM ) REAL * 8 :: kx , ky INTEGER * 4 :: orb , lat , n , m , spin !Transform from graphene reciprocal lattice to kx and ky kx = 2. * PI / ( SQRT ( 3.0d0 )) * k1 ky = - 2. * PI / 3. * k1 + 4. * PI / 3. * k2 Energies (:) = 0. Hamiltonian (:,:) = DCMPLX ( 0. , 0. ) U_transformation (:,:) = DCMPLX ( 0. , 0. ) CALL COMPUTE_TBA_TERM ( Hamiltonian (:,:), kx , ky ) CALL COMPUTE_TI1_TI2 ( Hamiltonian (:,:), kx , ky ) !There may be a problem since Ti1,Ti2 coupling is assumed to be equal Ti2,Ti1 CALL COMPUTE_H_PI ( Hamiltonian (:,:), kx , ky ) !There may be a problem since Ti1,Ti2 coupling is assumed to be equal Ti2,Ti1 CALL COMPUTE_H_SIGMA ( Hamiltonian (:,:), kx , ky ) !There may be a problem since Ti1,Ti2 coupling is assumed to be equal Ti2,Ti1 CALL COMPUTE_HUBBARD ( Hamiltonian (:,:), Charge_dens (:)) CALL COMPUTE_SC ( Hamiltonian (:,:), kx , ky , Gamma_SC (:,:,:,:)) CALL COMPUTE_CONJUGATE_ELEMENTS ( Hamiltonian (:,:), DIM ) !This is not needed, since ZHEEV takes only upper triangle Hamiltonian (:,:) = 0.5 * ( Hamiltonian_const (:,:) + Hamiltonian (:,:) ) !U_transformation(:,:) = Hamiltonian(:,:) !CALL DIAGONALIZE_HERMITIAN(U_transformation(:,:), Energies(i,j,:), DIM) ! CALL PRINT_HAMILTONIAN(Hamiltonian(:,:)) ! STOP 'Hamiltonian printed' CALL DIAGONALIZE_GENERALIZED ( Hamiltonian (:,:), Energies (:), U_transformation (:,:), DIM ) !After DIAGONALIZE HERMITIAN, U contains eigenvectors, so it corresponds to transformation matrix U !Here it has to be set to zero, to avoid artifacts from previous iteration / chunk Delta_local (:,:,:,:) = DCMPLX ( 0. , 0. ) !Self - consistent delta calculation DO orb = 1 , ORBITALS !### NEAREST NEIGHBOURS PAIRING ########################################### !Electrons DO n = 1 , DIM_POSITIVE_K !Up - down Ti1 - Ti2 delta Delta_local ( orb , 1 , 1 , 1 ) = Delta_local ( orb , 1 , 1 , 1 ) + CONJG ( U_transformation ( orb + DIM_POSITIVE_K , n )) * U_transformation ( orb + ORBITALS + TBA_DIM , n ) * fd_distribution ( Energies ( n ), 0 d0 , T ) * pairing_1 ( ky ) Delta_local ( orb , 2 , 1 , 1 ) = Delta_local ( orb , 2 , 1 , 1 ) + CONJG ( U_transformation ( orb + DIM_POSITIVE_K , n )) * U_transformation ( orb + ORBITALS + TBA_DIM , n ) * fd_distribution ( Energies ( n ), 0 d0 , T ) * pairing_2 ( kx , ky ) Delta_local ( orb , 3 , 1 , 1 ) = Delta_local ( orb , 3 , 1 , 1 ) + CONJG ( U_transformation ( orb + DIM_POSITIVE_K , n )) * U_transformation ( orb + ORBITALS + TBA_DIM , n ) * fd_distribution ( Energies ( n ), 0 d0 , T ) * pairing_3 ( kx , ky ) !Up - down Ti2 - Ti1 delta Delta_local ( orb , 1 , 1 , 2 ) = Delta_local ( orb , 1 , 1 , 2 ) + CONJG ( U_transformation ( orb + ORBITALS + DIM_POSITIVE_K , n )) * U_transformation ( orb + TBA_DIM , n ) * fd_distribution ( Energies ( n ), 0 d0 , T ) * CONJG ( pairing_1 ( ky )) Delta_local ( orb , 2 , 1 , 2 ) = Delta_local ( orb , 2 , 1 , 2 ) + CONJG ( U_transformation ( orb + ORBITALS + DIM_POSITIVE_K , n )) * U_transformation ( orb + TBA_DIM , n ) * fd_distribution ( Energies ( n ), 0 d0 , T ) * CONJG ( pairing_2 ( kx , ky )) Delta_local ( orb , 3 , 1 , 2 ) = Delta_local ( orb , 3 , 1 , 2 ) + CONJG ( U_transformation ( orb + ORBITALS + DIM_POSITIVE_K , n )) * U_transformation ( orb + TBA_DIM , n ) * fd_distribution ( Energies ( n ), 0 d0 , T ) * CONJG ( pairing_3 ( kx , ky )) !Down - up Ti1 - Ti2 delta Delta_local ( orb , 1 , 2 , 1 ) = Delta_local ( orb , 1 , 2 , 1 ) + CONJG ( U_transformation ( orb + DIM_POSITIVE_K + TBA_DIM , n )) * U_transformation ( orb + ORBITALS , n ) * fd_distribution ( Energies ( n ), 0 d0 , T ) * pairing_1 ( ky ) Delta_local ( orb , 2 , 2 , 1 ) = Delta_local ( orb , 2 , 2 , 1 ) + CONJG ( U_transformation ( orb + DIM_POSITIVE_K + TBA_DIM , n )) * U_transformation ( orb + ORBITALS , n ) * fd_distribution ( Energies ( n ), 0 d0 , T ) * pairing_2 ( kx , ky ) Delta_local ( orb , 3 , 2 , 1 ) = Delta_local ( orb , 3 , 2 , 1 ) + CONJG ( U_transformation ( orb + DIM_POSITIVE_K + TBA_DIM , n )) * U_transformation ( orb + ORBITALS , n ) * fd_distribution ( Energies ( n ), 0 d0 , T ) * pairing_3 ( kx , ky ) !Down - up Ti2 - Ti1 delta Delta_local ( orb , 1 , 2 , 2 ) = Delta_local ( orb , 1 , 2 , 2 ) + CONJG ( U_transformation ( orb + ORBITALS + DIM_POSITIVE_K + TBA_DIM , n )) * U_transformation ( orb , n ) * fd_distribution ( Energies ( n ), 0 d0 , T ) * CONJG ( pairing_1 ( ky )) Delta_local ( orb , 2 , 2 , 2 ) = Delta_local ( orb , 2 , 2 , 2 ) + CONJG ( U_transformation ( orb + ORBITALS + DIM_POSITIVE_K + TBA_DIM , n )) * U_transformation ( orb , n ) * fd_distribution ( Energies ( n ), 0 d0 , T ) * CONJG ( pairing_2 ( kx , ky )) Delta_local ( orb , 3 , 2 , 2 ) = Delta_local ( orb , 3 , 2 , 2 ) + CONJG ( U_transformation ( orb + ORBITALS + DIM_POSITIVE_K + TBA_DIM , n )) * U_transformation ( orb , n ) * fd_distribution ( Energies ( n ), 0 d0 , T ) * CONJG ( pairing_3 ( kx , ky )) END DO !Holes DO n = DIM_POSITIVE_K + 1 , DIM !Up - down Ti1 - Ti2 delta Delta_local ( orb , 1 , 1 , 1 ) = Delta_local ( orb , 1 , 1 , 1 ) + CONJG ( U_transformation ( orb + DIM_POSITIVE_K , n )) * U_transformation ( orb + ORBITALS + TBA_DIM , n ) * ( 1. - fd_distribution ( - Energies ( n ), 0 d0 , T )) * pairing_1 ( ky ) Delta_local ( orb , 2 , 1 , 1 ) = Delta_local ( orb , 2 , 1 , 1 ) + CONJG ( U_transformation ( orb + DIM_POSITIVE_K , n )) * U_transformation ( orb + ORBITALS + TBA_DIM , n ) * ( 1. - fd_distribution ( - Energies ( n ), 0 d0 , T )) * pairing_2 ( kx , ky ) Delta_local ( orb , 3 , 1 , 1 ) = Delta_local ( orb , 3 , 1 , 1 ) + CONJG ( U_transformation ( orb + DIM_POSITIVE_K , n )) * U_transformation ( orb + ORBITALS + TBA_DIM , n ) * ( 1. - fd_distribution ( - Energies ( n ), 0 d0 , T )) * pairing_3 ( kx , ky ) !Up - down Ti2 - Ti1 delta Delta_local ( orb , 1 , 1 , 2 ) = Delta_local ( orb , 1 , 1 , 2 ) + CONJG ( U_transformation ( orb + ORBITALS + DIM_POSITIVE_K , n )) * U_transformation ( orb + TBA_DIM , n ) * ( 1. - fd_distribution ( - Energies ( n ), 0 d0 , T )) * CONJG ( pairing_1 ( ky )) Delta_local ( orb , 2 , 1 , 2 ) = Delta_local ( orb , 2 , 1 , 2 ) + CONJG ( U_transformation ( orb + ORBITALS + DIM_POSITIVE_K , n )) * U_transformation ( orb + TBA_DIM , n ) * ( 1. - fd_distribution ( - Energies ( n ), 0 d0 , T )) * CONJG ( pairing_2 ( kx , ky )) Delta_local ( orb , 3 , 1 , 2 ) = Delta_local ( orb , 3 , 1 , 2 ) + CONJG ( U_transformation ( orb + ORBITALS + DIM_POSITIVE_K , n )) * U_transformation ( orb + TBA_DIM , n ) * ( 1. - fd_distribution ( - Energies ( n ), 0 d0 , T )) * CONJG ( pairing_3 ( kx , ky )) !Down - up Ti1 - Ti2 delta Delta_local ( orb , 1 , 2 , 1 ) = Delta_local ( orb , 1 , 2 , 1 ) + CONJG ( U_transformation ( orb + DIM_POSITIVE_K + TBA_DIM , n )) * U_transformation ( orb + ORBITALS , n ) * ( 1. - fd_distribution ( - Energies ( n ), 0 d0 , T )) * pairing_1 ( ky ) Delta_local ( orb , 2 , 2 , 1 ) = Delta_local ( orb , 2 , 2 , 1 ) + CONJG ( U_transformation ( orb + DIM_POSITIVE_K + TBA_DIM , n )) * U_transformation ( orb + ORBITALS , n ) * ( 1. - fd_distribution ( - Energies ( n ), 0 d0 , T )) * pairing_2 ( kx , ky ) Delta_local ( orb , 3 , 2 , 1 ) = Delta_local ( orb , 3 , 2 , 1 ) + CONJG ( U_transformation ( orb + DIM_POSITIVE_K + TBA_DIM , n )) * U_transformation ( orb + ORBITALS , n ) * ( 1. - fd_distribution ( - Energies ( n ), 0 d0 , T )) * pairing_3 ( kx , ky ) !Down - up Ti2 - Ti1 delta Delta_local ( orb , 1 , 2 , 2 ) = Delta_local ( orb , 1 , 2 , 2 ) + CONJG ( U_transformation ( orb + ORBITALS + DIM_POSITIVE_K + TBA_DIM , n )) * U_transformation ( orb , n ) * ( 1. - fd_distribution ( - Energies ( n ), 0 d0 , T )) * CONJG ( pairing_1 ( ky )) Delta_local ( orb , 2 , 2 , 2 ) = Delta_local ( orb , 2 , 2 , 2 ) + CONJG ( U_transformation ( orb + ORBITALS + DIM_POSITIVE_K + TBA_DIM , n )) * U_transformation ( orb , n ) * ( 1. - fd_distribution ( - Energies ( n ), 0 d0 , T )) * CONJG ( pairing_2 ( kx , ky )) Delta_local ( orb , 3 , 2 , 2 ) = Delta_local ( orb , 3 , 2 , 2 ) + CONJG ( U_transformation ( orb + ORBITALS + DIM_POSITIVE_K + TBA_DIM , n )) * U_transformation ( orb , n ) * ( 1. - fd_distribution ( - Energies ( n ), 0 d0 , T )) * CONJG ( pairing_3 ( kx , ky )) END DO !### END OF NEAREST NEIGHBOURS PAIRING ########################################### !### NEXT NEAREST NEIGHBOURS PAIRING ############################################ !Electrons DO n = 1 , DIM_POSITIVE_K !Up - down Ti1 - Ti1 delta, Ti2 - Ti2 delta !No conjugation in phase factor, since next nearest neighbours have the same relative positions in both sublattices DO lat = 0 , SUBLATTICES - 1 DO spin = 0 , 1 Delta_local ( orb , N_NEIGHBOURS + 1 , spin + 1 , lat + 1 ) = Delta_local ( orb , N_NEIGHBOURS + 1 , spin + 1 , lat + 1 ) + CONJG ( U_transformation ( orb + lat * ORBITALS + DIM_POSITIVE_K + TBA_DIM * spin , n )) * U_transformation ( orb + lat * ORBITALS + TBA_DIM * MOD ( spin + 1 , 2 ), n ) * fd_distribution ( Energies ( n ), 0 d0 , T ) * pairing_nnn_1 ( kx ) Delta_local ( orb , N_NEIGHBOURS + 2 , spin + 1 , lat + 1 ) = Delta_local ( orb , N_NEIGHBOURS + 2 , spin + 1 , lat + 1 ) + CONJG ( U_transformation ( orb + lat * ORBITALS + DIM_POSITIVE_K + TBA_DIM * spin , n )) * U_transformation ( orb + lat * ORBITALS + TBA_DIM * MOD ( spin + 1 , 2 ), n ) * fd_distribution ( Energies ( n ), 0 d0 , T ) * pairing_nnn_2 ( kx , ky ) Delta_local ( orb , N_NEIGHBOURS + 3 , spin + 1 , lat + 1 ) = Delta_local ( orb , N_NEIGHBOURS + 3 , spin + 1 , lat + 1 ) + CONJG ( U_transformation ( orb + lat * ORBITALS + DIM_POSITIVE_K + TBA_DIM * spin , n )) * U_transformation ( orb + lat * ORBITALS + TBA_DIM * MOD ( spin + 1 , 2 ), n ) * fd_distribution ( Energies ( n ), 0 d0 , T ) * pairing_nnn_3 ( kx , ky ) Delta_local ( orb , N_NEIGHBOURS + 4 , spin + 1 , lat + 1 ) = Delta_local ( orb , N_NEIGHBOURS + 4 , spin + 1 , lat + 1 ) + CONJG ( U_transformation ( orb + lat * ORBITALS + DIM_POSITIVE_K + TBA_DIM * spin , n )) * U_transformation ( orb + lat * ORBITALS + TBA_DIM * MOD ( spin + 1 , 2 ), n ) * fd_distribution ( Energies ( n ), 0 d0 , T ) * pairing_nnn_4 ( kx ) Delta_local ( orb , N_NEIGHBOURS + 5 , spin + 1 , lat + 1 ) = Delta_local ( orb , N_NEIGHBOURS + 5 , spin + 1 , lat + 1 ) + CONJG ( U_transformation ( orb + lat * ORBITALS + DIM_POSITIVE_K + TBA_DIM * spin , n )) * U_transformation ( orb + lat * ORBITALS + TBA_DIM * MOD ( spin + 1 , 2 ), n ) * fd_distribution ( Energies ( n ), 0 d0 , T ) * pairing_nnn_5 ( kx , ky ) Delta_local ( orb , N_NEIGHBOURS + 6 , spin + 1 , lat + 1 ) = Delta_local ( orb , N_NEIGHBOURS + 6 , spin + 1 , lat + 1 ) + CONJG ( U_transformation ( orb + lat * ORBITALS + DIM_POSITIVE_K + TBA_DIM * spin , n )) * U_transformation ( orb + lat * ORBITALS + TBA_DIM * MOD ( spin + 1 , 2 ), n ) * fd_distribution ( Energies ( n ), 0 d0 , T ) * pairing_nnn_6 ( kx , ky ) END DO END DO END DO !Holes DO n = DIM_POSITIVE_K + 1 , DIM !Up - down Ti1 - Ti1 delta, Ti2 - Ti2 delta !No conjugation in phase factor, since next nearest neighbours have the same relative positions in both sublattices DO lat = 0 , SUBLATTICES - 1 DO spin = 0 , 1 Delta_local ( orb , N_NEIGHBOURS + 1 , spin + 1 , lat + 1 ) = Delta_local ( orb , N_NEIGHBOURS + 1 , spin + 1 , lat + 1 ) + CONJG ( U_transformation ( orb + lat * ORBITALS + DIM_POSITIVE_K + TBA_DIM * spin , n )) * U_transformation ( orb + lat * ORBITALS + TBA_DIM * MOD ( spin + 1 , 2 ), n ) * ( 1. - fd_distribution ( - Energies ( n ), 0 d0 , T )) * pairing_nnn_1 ( kx ) Delta_local ( orb , N_NEIGHBOURS + 2 , spin + 1 , lat + 1 ) = Delta_local ( orb , N_NEIGHBOURS + 2 , spin + 1 , lat + 1 ) + CONJG ( U_transformation ( orb + lat * ORBITALS + DIM_POSITIVE_K + TBA_DIM * spin , n )) * U_transformation ( orb + lat * ORBITALS + TBA_DIM * MOD ( spin + 1 , 2 ), n ) * ( 1. - fd_distribution ( - Energies ( n ), 0 d0 , T )) * pairing_nnn_2 ( kx , ky ) Delta_local ( orb , N_NEIGHBOURS + 3 , spin + 1 , lat + 1 ) = Delta_local ( orb , N_NEIGHBOURS + 3 , spin + 1 , lat + 1 ) + CONJG ( U_transformation ( orb + lat * ORBITALS + DIM_POSITIVE_K + TBA_DIM * spin , n )) * U_transformation ( orb + lat * ORBITALS + TBA_DIM * MOD ( spin + 1 , 2 ), n ) * ( 1. - fd_distribution ( - Energies ( n ), 0 d0 , T )) * pairing_nnn_3 ( kx , ky ) Delta_local ( orb , N_NEIGHBOURS + 4 , spin + 1 , lat + 1 ) = Delta_local ( orb , N_NEIGHBOURS + 4 , spin + 1 , lat + 1 ) + CONJG ( U_transformation ( orb + lat * ORBITALS + DIM_POSITIVE_K + TBA_DIM * spin , n )) * U_transformation ( orb + lat * ORBITALS + TBA_DIM * MOD ( spin + 1 , 2 ), n ) * ( 1. - fd_distribution ( - Energies ( n ), 0 d0 , T )) * pairing_nnn_4 ( kx ) Delta_local ( orb , N_NEIGHBOURS + 5 , spin + 1 , lat + 1 ) = Delta_local ( orb , N_NEIGHBOURS + 5 , spin + 1 , lat + 1 ) + CONJG ( U_transformation ( orb + lat * ORBITALS + DIM_POSITIVE_K + TBA_DIM * spin , n )) * U_transformation ( orb + lat * ORBITALS + TBA_DIM * MOD ( spin + 1 , 2 ), n ) * ( 1. - fd_distribution ( - Energies ( n ), 0 d0 , T )) * pairing_nnn_5 ( kx , ky ) Delta_local ( orb , N_NEIGHBOURS + 6 , spin + 1 , lat + 1 ) = Delta_local ( orb , N_NEIGHBOURS + 6 , spin + 1 , lat + 1 ) + CONJG ( U_transformation ( orb + lat * ORBITALS + DIM_POSITIVE_K + TBA_DIM * spin , n )) * U_transformation ( orb + lat * ORBITALS + TBA_DIM * MOD ( spin + 1 , 2 ), n ) * ( 1. - fd_distribution ( - Energies ( n ), 0 d0 , T )) * pairing_nnn_6 ( kx , ky ) END DO END DO END DO !### END OF NEXT NEAREST NEIGHBOURS PAIRING ##################################### END DO !Here it has to be set to zero, to avoid artifacts from previous iteration / chunk Charge_dens_local (:) = 0. !Charge density calculation DO m = 1 , DIM_POSITIVE_K DO n = 1 , DIM_POSITIVE_K Charge_dens_local ( m ) = Charge_dens_local ( m ) + U_transformation ( m , n ) * CONJG ( U_transformation ( m , n )) * fd_distribution ( Energies ( n ), 0 d0 , T ) + & & U_transformation ( m , DIM_POSITIVE_K + n ) * CONJG ( U_transformation ( m , DIM_POSITIVE_K + n )) * ( 1. - fd_distribution ( - Energies ( DIM_POSITIVE_K + n ), 0 d0 , T )) END DO END DO END SUBROUTINE GET_LOCAL_CHARGE_AND_DELTA END MODULE mod_compute_hamiltonians","tags":"","loc":"sourcefile/mod_compute_hamiltonians.f90.html"},{"title":"main.f90 – Fortran Program","text":"Source Code PROGRAM MAIN USE mod_hamiltonians USE mod_parameters USE mod_utilities USE mod_writers USE mod_reader USE mod_broydenV2 USE mod_compute_hamiltonians USE mod_integrate IMPLICIT NONE COMPLEX * 16 , ALLOCATABLE :: Hamiltonian (:,:), Hamiltonian_const (:,:), U_transformation (:,:) REAL * 8 , ALLOCATABLE :: Energies (:) COMPLEX * 16 , ALLOCATABLE :: Delta_local (:,:,:,:), Delta_new (:,:,:,:) REAL * 8 , ALLOCATABLE :: Delta_broyden (:), Delta_new_broyden (:) COMPLEX * 16 , ALLOCATABLE :: Gamma_SC (:,:,:,:), Gamma_SC_new (:,:,:,:) REAL * 8 , ALLOCATABLE :: Charge_dens (:), Charge_dens_new (:), Charge_dens_local (:) REAL * 8 :: gamma_error , gamma_max_error , charge_error , charge_max_error REAL * 8 :: gamma_max_error_prev , charge_max_error_prev INTEGER * 4 :: i , j , n , lat , orb , orb_prime , spin INTEGER * 4 :: sc_iter LOGICAL :: sc_flag INTEGER * 4 :: counter INTEGER * 4 :: delta_real_elems INTEGER * 4 :: broyden_index !N_NEIGHBOURS + N_NEXT_NEIGHBOURS = 9, to implement both pairings !2 because spin up-down and down-up, !2 because of complex number !SUBLATTICES because of Ti1-Ti2 coupling and Ti2 - Ti1 coupling (stored in this order) !DIM_POSITIVE_K included due to Charge density self-consistency delta_real_elems = DIM_POSITIVE_K + ORBITALS * N_ALL_NEIGHBOURS * 2 * 2 * SUBLATTICES !SUBLATTICES should be excluded in absence of magnetic field CALL GET_INPUT ( \"./input.nml\" ) !Basis !c_{k,yz,Ti1,up}, c_{k,zx,Ti1,up}, c_{k,xy,Ti1,up}, !c_{k,yz,Ti2,up}, c_{k,zx,Ti2,up}, c_{k,xy,Ti2,up}, !c_{k,yz,Ti1,down}, c_{k,zx,Ti1,down}, c_{k,xy,Ti1,down}, !c_{k,yz,Ti2,down}, c_{k,zx,Ti2,down}, c_{k,xy,Ti2,down}, ! + H.c{-k} ALLOCATE ( Hamiltonian ( DIM , DIM )) ALLOCATE ( Hamiltonian_const ( DIM , DIM )) ALLOCATE ( U_transformation ( DIM , DIM )) ALLOCATE ( Energies ( DIM )) ALLOCATE ( Delta_local ( ORBITALS , N_ALL_NEIGHBOURS , 2 , SUBLATTICES )) !Third dimension for spin coupling up-down and down-up ALLOCATE ( Delta_new ( ORBITALS , N_ALL_NEIGHBOURS , 2 , SUBLATTICES )) ALLOCATE ( Gamma_SC ( ORBITALS , N_ALL_NEIGHBOURS , 2 , SUBLATTICES )) ALLOCATE ( Gamma_SC_new ( ORBITALS , N_ALL_NEIGHBOURS , 2 , SUBLATTICES )) ALLOCATE ( Delta_broyden ( delta_real_elems )) !Flattened Gamma array ALLOCATE ( Delta_new_broyden ( delta_real_elems )) ALLOCATE ( Charge_dens ( DIM_POSITIVE_K )) ALLOCATE ( Charge_dens_local ( DIM_POSITIVE_K )) ALLOCATE ( Charge_dens_new ( DIM_POSITIVE_K )) !Initializations Hamiltonian (:,:) = DCMPLX ( 0. , 0. ) Hamiltonian_const (:,:) = DCMPLX ( 0. , 0. ) U_transformation (:,:) = DCMPLX ( 0. , 0. ) Energies (:) = 0. Delta_local (:,:,:,:) = DCMPLX ( 0. , 0. ) Delta_new (:,:,:,:) = DCMPLX ( 0. , 0. ) !Breaking spin up-down down-up symmetry !coupling for nearest-neighbours Gamma_SC (:,: N_NEIGHBOURS , 1 ,:) = DCMPLX ( gamma_start , 0. ) Gamma_SC (:,: N_NEIGHBOURS , 2 ,:) = DCMPLX ( - gamma_start , 0. ) !coupling for next nearest neighbours Gamma_SC (:, N_NEIGHBOURS : N_NEXT_NEIGHBOURS , 1 ,:) = DCMPLX ( gamma_start / 1 0. , 0. ) Gamma_SC (:, N_NEIGHBOURS : N_NEXT_NEIGHBOURS , 2 ,:) = DCMPLX ( - gamma_start / 1 0. , 0. ) !Gamma_SC(:,:,:) = DCMPLX(0., 0.) Gamma_SC_new (:,:,:,:) = DCMPLX ( 0. , 0. ) Charge_dens (:) = charge_start Charge_dens_new (:) = 0. Charge_dens_local (:) = 0. Delta_broyden (:) = 0. Delta_new_broyden (:) = 0. gamma_max_error = 0. charge_max_error = 0. !Computing k-independent terms CALL COMPUTE_TRIGONAL_TERMS ( Hamiltonian_const (:,:)) CALL COMPUTE_ATOMIC_SOC_TERMS ( Hamiltonian_const (:,:)) CALL COMPUTE_ELECTRIC_FIELD ( Hamiltonian_const (:,:)) DO n = 1 , DIM_POSITIVE_K Hamiltonian_const ( n , n ) = Hamiltonian_const ( n , n ) - E_Fermi Hamiltonian_const ( DIM_POSITIVE_K + n , DIM_POSITIVE_K + n ) = Hamiltonian_const ( DIM_POSITIVE_K + n , DIM_POSITIVE_K + n ) + E_Fermi END DO CALL COMPUTE_CONJUGATE_ELEMENTS ( Hamiltonian_const (:,:), DIM ) !This is not needed, since ZHEEV takes only upper triangle OPEN ( unit = 99 , FILE = \"./OutputData/Convergence.dat\" , FORM = \"FORMATTED\" , ACTION = \"WRITE\" ) DO sc_iter = 1 , max_sc_iter PRINT * , \"============= SC_ITER: \" , sc_iter !PRINT*, \"Gamma = \", Gamma_SC(1,1,1,1)/meV2au counter = 0 !Those loops are only for slicing and future parallelization !Integration over chunks is computed via Romberg algorithm. DO i = 0 , k1_steps - 1 DO j = 0 , k2_steps - 1 counter = counter + 1 !PRINT*, counter CALL ROMBERG_Y ( Hamiltonian_const (:,:), Gamma_SC (:,:,:,:), Charge_dens (:), i * dk1 , ( i + 1 ) * dk1 , j * dk2 , ( j + 1 ) * dk2 , & & Delta_local (:,:,:,:), Charge_dens_local (:), romb_eps_x , interpolation_deg_x , max_grid_refinements_x , & & romb_eps_y , interpolation_deg_y , max_grid_refinements_y ) !This has to be atomic operations, since Delta_new and Charge_dens would be global variables for all threads Delta_new (:,:,:,:) = Delta_new (:,:,:,:) + Delta_local (:,:,:,:) Charge_dens_new (:) = Charge_dens_new (:) + Charge_dens_local (:) END DO END DO !End of k-loop !Due to change of sum to integral one has to divide by Brillouin zone volume !Jacobian and volume of Brillouin zone cancel out thus no multiplier Delta_new (:,:,:,:) = Delta_new (:,:,:,:) Charge_dens_new (:) = Charge_dens_new (:) ! !Integration with simple trapezoid rule ! DO i = 0, k1_steps !     counter = counter + 1 !     PRINT*, counter !     DO j = 0, k2_steps !         CALL GET_LOCAL_CHARGE_AND_DELTA(Hamiltonian_const(:,:), Gamma_SC(:,:,:,:), & !         & Charge_dens(:), i*dk1, j*dk2, Delta_local(:,:,:,:), Charge_dens_local(:)) !         Delta_new(:,:,:,:) = Delta_new(:,:,:,:) + Delta_local(:,:,:,:)*dk1*dk2 !         Charge_dens_new(:) = Charge_dens_new(:) + Charge_dens_local(:)*dk1*dk2 !     END DO ! END DO !Jacobian and volume of Brillouin zone cancel out thus no multiplier ! Delta_new(:,:,:,:) = Delta_new(:,:,:,:) ! Charge_dens_new(:) = Charge_dens_new(:) ! DO i = 1, DIM_POSITIVE_K !     PRINT*, \"Charge elem \", i, \" = \", Charge_dens_new(i) ! END DO !######################################################################################################################### !This is a critical section - only one thread can execute that and all thread should have ended their job up to that point !######################################################################################################################### !Delta_new(:,:,:,:) = Delta_new(:,:,:,:) * domega ! because of changing sum to integral !Charge_dens(:) = Charge_dens(:) * domega !Gamma calculation DO spin = 1 , 2 !Loop over spin coupling up-down or down-up DO n = 1 , N_NEIGHBOURS !Loop over neighbours DO lat = 1 , SUBLATTICES !Loop over sublattices coupling DO orb = 1 , ORBITALS Gamma_SC_new ( orb , n , spin , lat ) = - 0.5 * J_SC * Delta_new ( orb , n , spin , lat ) DO orb_prime = 1 , ORBITALS IF ( orb . NE . orb_prime ) THEN ! CHECK WHETHER THIS IS 0.25 OR 0.5 Gamma_SC_new ( orb , n , spin , lat ) = Gamma_SC_new ( orb , n , spin , lat ) - 0.5 * J_SC_PRIME * Delta_new ( orb_prime , n , spin , lat ) END IF END DO END DO END DO END DO END DO !Gamma for next nearest neighbours pairing DO spin = 1 , 2 !Loop over spin coupling up-down or down-up DO n = N_NEIGHBOURS , N_ALL_NEIGHBOURS !Loop over next nearest neighbours DO lat = 1 , SUBLATTICES !Loop over sublattices coupling DO orb = 1 , ORBITALS Gamma_SC_new ( orb , n , spin , lat ) = - 0.5 * J_SC_NNN * Delta_new ( orb , n , spin , lat ) DO orb_prime = 1 , ORBITALS IF ( orb . NE . orb_prime ) THEN ! CHECK WHETHER THIS IS 0.25 OR 0.5 Gamma_SC_new ( orb , n , spin , lat ) = Gamma_SC_new ( orb , n , spin , lat ) - 0.5 * J_SC_PRIME_NNN * Delta_new ( orb_prime , n , spin , lat ) END IF END DO END DO END DO END DO END DO !PRINT*, \"Gamma new = \", Gamma_SC_new(1,1,1,1)/meV2au !PRINT*, \"Filling \", SUM(Charge_dens(:)) / DIM_POSITIVE_K gamma_max_error_prev = gamma_max_error charge_max_error_prev = charge_max_error gamma_max_error = 0. charge_max_error = 0. !Here we check whether convergence was reached sc_flag = . TRUE . DO spin = 1 , 2 DO orb = 1 , ORBITALS DO n = 1 , N_ALL_NEIGHBOURS DO lat = 1 , 1 !to 1 in absence of magnetic field to SUBLATTICES if else !It should be considered whether relative or absolute error must be checked gamma_error = ABS ( ABS ( Gamma_SC_new ( orb , n , spin , lat )) - ABS ( Gamma_SC ( orb , n , spin , lat )) ) !Gamma convergence checking IF ( gamma_error > gamma_eps_convergence ) THEN sc_flag = . FALSE . !EXIT !Maybe go to??? END IF !Find biggest error in current iteration IF ( gamma_error > gamma_max_error ) gamma_max_error = gamma_error END DO END DO END DO END DO !Change Broyden mixing parameter if simulation diverges between iterations !To avoid oscillations near convergence IF ( ABS ( gamma_max_error ) > ABS ( gamma_max_error_prev )) THEN PRINT * , \"Adapted sc_alpha = \" , sc_alpha sc_alpha = sc_alpha * sc_alpha_adapt END IF DO n = 1 , DIM_POSITIVE_K charge_error = ABS ( Charge_dens ( n ) - Charge_dens_new ( n )) IF ( charge_error > charge_eps_convergence ) THEN sc_flag = . FALSE . END IF IF ( charge_error > charge_max_error ) charge_max_error = charge_error END DO IF ( sc_flag ) THEN PRINT * , \"Convergence reached!\" EXIT END IF WRITE ( 99 , '(I0, 8E15.5)' ) sc_iter , REAL ( Gamma_SC ( 1 , 1 , 1 , 1 ) / meV2au ), AIMAG ( Gamma_SC ( 1 , 1 , 1 , 1 ) / meV2au ), & & REAL ( Gamma_SC_new ( 1 , 1 , 1 , 1 ) / meV2au ), AIMAG ( Gamma_SC_new ( 1 , 1 , 1 , 1 ) / meV2au ), & & Charge_dens ( 1 ), Charge_dens_new ( 1 ), gamma_max_error / meV2au , charge_max_error !PRINT*, \"Gamma max error \", gamma_max_error !In the beginning of convergence use Broyden method to quickly find minimum ! IF (gamma_max_error  > 1e-3) THEN !PRINT*, \"Broyden mixing\" !Broyden mixing !Flatten arrays for Broyden mixing broyden_index = 1 DO spin = 1 , 2 DO orb = 1 , ORBITALS DO n = 1 , N_ALL_NEIGHBOURS DO lat = 1 , 2 !to 1 in absence of magnetic field to SUBLATTICES if else Delta_broyden ( broyden_index ) = REAL ( Gamma_SC ( orb , n , spin , lat )) Delta_broyden ( INT (( delta_real_elems - DIM_POSITIVE_K ) / 2 ) + broyden_index ) = AIMAG ( Gamma_SC ( orb , n , spin , lat )) Delta_new_broyden ( broyden_index ) = REAL ( Gamma_SC_new ( orb , n , spin , lat )) Delta_new_broyden ( INT (( delta_real_elems - DIM_POSITIVE_K ) / 2 ) + broyden_index ) = AIMAG ( Gamma_SC_new ( orb , n , spin , lat )) broyden_index = broyden_index + 1 END DO END DO END DO END DO !Must be +1!!! Delta_broyden (( delta_real_elems - DIM_POSITIVE_K + 1 ) : delta_real_elems ) = Charge_dens (:) Delta_new_broyden (( delta_real_elems - DIM_POSITIVE_K + 1 ) : delta_real_elems ) = Charge_dens_new (:) !PRINT*, \"Filled table for broyden mixing, calling mix_broyden\" CALL mix_broyden ( delta_real_elems , Delta_new_broyden (:), Delta_broyden (:), sc_alpha , sc_iter , 4 , . FALSE .) !PRINT*, \"Finished mix_broyden, rewriting to Gamma\" broyden_index = 1 DO spin = 1 , 2 DO orb = 1 , ORBITALS DO n = 1 , N_ALL_NEIGHBOURS DO lat = 1 , 2 !to 1 in absence of magnetic field to SUBLATTICES if else Gamma_SC ( orb , n , spin , lat ) = DCMPLX ( Delta_broyden ( broyden_index ), Delta_broyden ( INT (( delta_real_elems - DIM_POSITIVE_K ) / 2 ) + broyden_index )) broyden_index = broyden_index + 1 END DO END DO END DO END DO Charge_dens (:) = Delta_broyden (( delta_real_elems - DIM_POSITIVE_K + 1 ): delta_real_elems ) !In the last phase of convergence use linear mixing to avoid spare oscillations ! ELSE !     PRINT*, \"Linear mixing\" !     !Linear mixing !     Gamma_SC(:,:,:,:) = (1. - sc_alpha)*Gamma_SC(:,:,:,:) + sc_alpha*Gamma_SC_new(:,:,:,:) ! END IF !Gamma_SC(:,:,:,2) = CONJG(Gamma_SC(:,:,:,1)) !This is valid in asbence of magnetic field Delta_new (:,:,:,:) = DCMPLX ( 0. , 0. ) Gamma_SC_new (:,:,:,:) = DCMPLX ( 0. , 0. ) Charge_dens_new (:) = 0. !To check the state of the simulation CALL PRINT_GAMMA ( Gamma_SC (:,:,:,:), \"Gamma_SC_iter\" ) CALL PRINT_CHARGE ( Charge_dens (:), \"Charge_dens_iter\" ) END DO !End of SC loop CLOSE ( 99 ) !Printing results after the simulation is done CALL PRINT_GAMMA ( Gamma_SC (:,:,:,:), \"Gamma_SC_final\" ) CALL PRINT_CHARGE ( Charge_dens (:), \"Charge_dens_final\" ) !Just for memory deallocation, the .TRUE. flag is crucial CALL mix_broyden ( delta_real_elems , Delta_new_broyden (:), Delta_broyden (:), sc_alpha , sc_iter , 4 , . TRUE .) DEALLOCATE ( Hamiltonian ) DEALLOCATE ( Hamiltonian_const ) DEALLOCATE ( Energies ) DEALLOCATE ( Delta_local ) DEALLOCATE ( Delta_new ) DEALLOCATE ( Gamma_SC ) DEALLOCATE ( Gamma_SC_new ) DEALLOCATE ( U_transformation ) DEALLOCATE ( Delta_broyden ) DEALLOCATE ( Delta_new_broyden ) DEALLOCATE ( Charge_dens ) DEALLOCATE ( Charge_dens_local ) DEALLOCATE ( Charge_dens_new ) END PROGRAM MAIN","tags":"","loc":"sourcefile/main.f90.html"},{"title":"mod_integrate.f90 – Fortran Program","text":"Source Code MODULE mod_integrate USE mod_parameters USE mod_compute_hamiltonians IMPLICIT NONE CONTAINS !Adapted from \"Numerical Recipes in Fortran Second Edition\" !William H. Press, Saul A. Teukolsky, W. T. Vetterling, B. P. Flannery SUBROUTINE ROMBERG_Y ( Hamiltonian_const , Gamma_SC , Charge_dens , k1_chunk_min , k1_chunk_max , k2_chunk_min , k2_chunk_max , & & Delta_local , Charge_dens_local , romb_eps_x , interpolation_deg_x , max_grid_refinements_x , & & romb_eps_y , interpolation_deg_y , max_grid_refinements_y ) COMPLEX * 16 , INTENT ( IN ) :: Hamiltonian_const ( DIM , DIM ) REAL * 8 , INTENT ( IN ) :: k1_chunk_min , k1_chunk_max , k2_chunk_min , k2_chunk_max COMPLEX * 16 , INTENT ( IN ) :: Gamma_SC ( ORBITALS , N_ALL_NEIGHBOURS , 2 , SUBLATTICES ) REAL * 8 , INTENT ( IN ) :: Charge_dens ( DIM_POSITIVE_K ) REAL * 8 , INTENT ( IN ) :: romb_eps_x , romb_eps_y INTEGER * 4 , INTENT ( IN ) :: interpolation_deg_x , interpolation_deg_y , max_grid_refinements_x , max_grid_refinements_y COMPLEX * 16 , INTENT ( OUT ) :: Delta_local ( ORBITALS , N_ALL_NEIGHBOURS , 2 , SUBLATTICES ) REAL * 8 , INTENT ( OUT ) :: Charge_dens_local ( DIM_POSITIVE_K ) !Parameters for Romberg integration COMPLEX * 16 :: stepsize ( max_grid_refinements_y + 1 ) COMPLEX * 16 :: Delta_iterations ( ORBITALS , N_ALL_NEIGHBOURS , 2 , SUBLATTICES , max_grid_refinements_y + 1 ) REAL * 8 :: Charge_dens_iterations ( DIM_POSITIVE_K , max_grid_refinements_y + 1 ) COMPLEX * 16 :: Delta_sum ( ORBITALS , N_ALL_NEIGHBOURS , 2 , SUBLATTICES ) REAL * 8 :: Charge_dens_sum ( DIM_POSITIVE_K ) COMPLEX * 16 :: result_error , result INTEGER * 4 :: n , i , j , spin , orb , lat REAL * 8 :: dk2_trap , k2_trap LOGICAL :: convergence stepsize = DCMPLX ( 0. , 0. ) Delta_iterations = DCMPLX ( 0. , 0. ) Charge_dens_iterations = DCMPLX ( 0. , 0. ) convergence = . FALSE . !stepsize(1) = k2_chunk_max - k2_chunk_min stepsize ( 1 ) = 1. DO j = 1 , max_grid_refinements_y !TRAPZD IMPLEMENTATION HERE !First approximation of the integral is taking only boundary values IF ( j == 1 ) THEN !Calculation for lower bound of chunk CALL ROMBERG_X ( Hamiltonian_const (:,:), Gamma_SC (:,:,:,:), Charge_dens (:), k1_chunk_min , k1_chunk_max , k2_chunk_max ,& & Delta_local (:,:,:,:), Charge_dens_local (:), romb_eps_x , interpolation_deg_x , max_grid_refinements_x ) Delta_iterations (:,:,:,:, j ) = Delta_local (:,:,:,:) Charge_dens_iterations (:, j ) = Charge_dens_local (:) !Calculation for upper bound of chunk CALL ROMBERG_X ( Hamiltonian_const (:,:), Gamma_SC (:,:,:,:), Charge_dens (:), k1_chunk_min , k1_chunk_max , k2_chunk_min ,& & Delta_local (:,:,:,:), Charge_dens_local (:), romb_eps_x , interpolation_deg_x , max_grid_refinements_x ) Delta_iterations (:,:,:,:, j ) = Delta_iterations (:,:,:,:, j ) + Delta_local (:,:,:,:) Charge_dens_iterations (:, j ) = Charge_dens_iterations (:, j ) + Charge_dens_local (:) Delta_iterations (:,:,:,:, j ) = 0.5 * ( k2_chunk_max - k2_chunk_min ) * Delta_iterations (:,:,:,:, j ) Charge_dens_iterations (:, j ) = 0.5 * ( k2_chunk_max - k2_chunk_min ) * Charge_dens_iterations (:, j ) !Next approximations take point in between already calculated points ! i.e make the grid twice as dense as in previous iteration ELSE i = 2 ** ( j - 2 ) dk2_trap = ( k2_chunk_max - k2_chunk_min ) / i k2_trap = k2_chunk_min + 0.5 * dk2_trap Delta_sum (:,:,:,:) = DCMPLX ( 0. , 0. ) Charge_dens_sum (:) = 0. ! Delta_iterations(:,:,:,:,j) = DCMPLX(0. , 0.) ! Charge_dens_iterations(:,j) = DCMPLX(0. , 0.) DO n = 1 , i !Here we pass k1_trap as actual k1 point CALL ROMBERG_X ( Hamiltonian_const (:,:), Gamma_SC (:,:,:,:), Charge_dens (:), k1_chunk_min , k1_chunk_max , k2_trap ,& & Delta_local (:,:,:,:), Charge_dens_local (:), romb_eps_x , interpolation_deg_x , max_grid_refinements_x ) Delta_sum (:,:,:,:) = Delta_sum (:,:,:,:) + Delta_local (:,:,:,:) Charge_dens_sum (:) = Charge_dens_sum (:) + Charge_dens_local (:) ! Delta_iterations(:,:,:,:,j) =  Delta_iterations(:,:,:,:,j) + Delta_local(:,:,:,:) ! Charge_dens_iterations(:,j) = Charge_dens_iterations(:,j) + Charge_dens_local(:) k2_trap = k2_trap + dk2_trap END DO Delta_iterations (:,:,:,:, j ) = 0.5 * ( Delta_iterations (:,:,:,:, j ) + ( k2_chunk_max - k2_chunk_min ) * Delta_sum (:,:,:,:) / i ) Charge_dens_iterations (:, j ) = 0.5 * ( Charge_dens_iterations (:, j ) + ( k2_chunk_max - k2_chunk_min ) * Charge_dens_sum (:) / i ) !!!!!!!! THIS PART COULD LEAD TO A PROBLEM !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Delta_iterations(:,:,:,:,j) = 0.5*(k2_chunk_max - k2_chunk_min)/i * Delta_iterations(:,:,:,:,j) ! Charge_dens_iterations(:,j) = 0.5*(k2_chunk_max - k2_chunk_min)/i * Charge_dens_iterations(:,j) !Summing all previously calculated values !They were calculated in different points ! DO n = 1, j !     Delta_iterations(:,:,:,:,j) =  Delta_iterations(:,:,:,:,j) + 0.5*Delta_iterations(:,:,:,:,n) !     Charge_dens_iterations(:,j) = Charge_dens_iterations(:,j) + 0.5*Charge_dens_iterations(:,n) ! END DO !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! IF ( j >= interpolation_deg_y ) THEN !For all components of Delta_iterations and Charge_dens_iterations !Check whether integral when dk1 ---> 0 can be approximated !With relative error no bigger than EPS convergence = . TRUE . !Checking Delta_iterations convergence DO spin = 1 , 2 DO orb = 1 , ORBITALS DO n = 1 , N_ALL_NEIGHBOURS DO lat = 1 , SUBLATTICES CALL POLINT ( stepsize (( j - interpolation_deg_y + 1 ): j ), Delta_iterations ( orb , n , spin , lat ,( j - interpolation_deg_y + 1 ): j ), & & interpolation_deg_y , DCMPLX ( 0. , 0. ), result , result_error ) Delta_local ( orb , n , spin , lat ) = result IF ( ABS ( result_error ) > romb_eps_y * ABS ( result )) THEN convergence = . FALSE . END IF END DO END DO END DO END DO !Chaecking Charge_dens convergence DO n = 1 , DIM_POSITIVE_K CALL POLINT ( stepsize (( j - interpolation_deg_y + 1 ): j ), DCMPLX ( Charge_dens_iterations ( n ,( j - interpolation_deg_y + 1 ): j ), 0. ), & & interpolation_deg_y , DCMPLX ( 0. , 0. ), result , result_error ) Charge_dens_local ( n ) = REAL ( result ) IF ( ABS ( result_error ) > romb_eps_y * ABS ( result )) THEN convergence = . FALSE . END IF END DO END IF END IF IF ( convergence ) THEN RETURN ELSE Delta_iterations (:,:,:,:, j + 1 ) = Delta_iterations (:,:,:,:, j ) Charge_dens_iterations (:, j + 1 ) = Charge_dens_iterations (:, j ) stepsize ( j + 1 ) = 0.25 * stepsize ( j ) END IF END DO END SUBROUTINE ROMBERG_Y SUBROUTINE ROMBERG_X ( Hamiltonian_const , Gamma_SC , Charge_dens , k1_chunk_min , k1_chunk_max , k2_actual , Delta_local , Charge_dens_local , & & romb_eps_x , interpolation_deg_x , max_grid_refinements_x ) COMPLEX * 16 , INTENT ( IN ) :: Hamiltonian_const ( DIM , DIM ) REAL * 8 , INTENT ( IN ) :: k1_chunk_min , k1_chunk_max , k2_actual COMPLEX * 16 , INTENT ( IN ) :: Gamma_SC ( ORBITALS , N_ALL_NEIGHBOURS , 2 , SUBLATTICES ) REAL * 8 , INTENT ( IN ) :: Charge_dens ( DIM_POSITIVE_K ) REAL * 8 , INTENT ( IN ) :: romb_eps_x INTEGER * 4 , INTENT ( IN ) :: interpolation_deg_x , max_grid_refinements_x COMPLEX * 16 , INTENT ( OUT ) :: Delta_local ( ORBITALS , N_ALL_NEIGHBOURS , 2 , SUBLATTICES ) REAL * 8 , INTENT ( OUT ) :: Charge_dens_local ( DIM_POSITIVE_K ) COMPLEX * 16 :: stepsize ( max_grid_refinements_x + 1 ) COMPLEX * 16 :: Delta_iterations ( ORBITALS , N_ALL_NEIGHBOURS , 2 , SUBLATTICES , max_grid_refinements_x + 1 ) REAL * 8 :: Charge_dens_iterations ( DIM_POSITIVE_K , max_grid_refinements_x + 1 ) COMPLEX * 16 :: Delta_sum ( ORBITALS , N_ALL_NEIGHBOURS , 2 , SUBLATTICES ) REAL * 8 :: Charge_dens_sum ( DIM_POSITIVE_K ) COMPLEX * 16 :: result_error , result INTEGER * 4 :: n , i , j , spin , orb , lat REAL * 8 :: dk1_trap , k1_trap LOGICAL :: convergence stepsize = DCMPLX ( 0. , 0. ) Delta_iterations = DCMPLX ( 0. , 0. ) Charge_dens_iterations = DCMPLX ( 0. , 0. ) convergence = . FALSE . !stepsize(1) = k1_chunk_max - k1_chunk_min stepsize ( 1 ) = 1. DO j = 1 , max_grid_refinements_x !TRAPZD IMPLEMENTATION HERE !First approximation of the integral is taking only boundary values IF ( j == 1 ) THEN !Calculation for lower bound of chunk CALL GET_LOCAL_CHARGE_AND_DELTA ( Hamiltonian_const (:,:), Gamma_SC (:,:,:,:), & & Charge_dens (:), k1_chunk_min , k2_actual , Delta_local , Charge_dens_local ) Delta_iterations (:,:,:,:, j ) = Delta_local (:,:,:,:) Charge_dens_iterations (:, j ) = Charge_dens_local (:) !Calculation for upper bound of chunk CALL GET_LOCAL_CHARGE_AND_DELTA ( Hamiltonian_const (:,:), Gamma_SC (:,:,:,:), & & Charge_dens (:), k1_chunk_max , k2_actual , Delta_local , Charge_dens_local ) Delta_iterations (:,:,:,:, j ) = Delta_iterations (:,:,:,:, j ) + Delta_local (:,:,:,:) Charge_dens_iterations (:, j ) = Charge_dens_iterations (:, j ) + Charge_dens_local (:) Delta_iterations (:,:,:,:, j ) = 0.5 * ( k1_chunk_max - k1_chunk_min ) * Delta_iterations (:,:,:,:, j ) Charge_dens_iterations (:, j ) = 0.5 * ( k1_chunk_max - k1_chunk_min ) * Charge_dens_iterations (:, j ) !Next approximations take point in between already calculated points ! i.e make the grid twice as dense as in previous iteration ELSE i = 2 ** ( j - 2 ) dk1_trap = ( k1_chunk_max - k1_chunk_min ) / i k1_trap = k1_chunk_min + 0.5 * dk1_trap Delta_sum (:,:,:,:) = DCMPLX ( 0. , 0. ) Charge_dens_sum (:) = 0. DO n = 1 , i !Here we pass k1_trap as actual k1 point CALL GET_LOCAL_CHARGE_AND_DELTA ( Hamiltonian_const (:,:), Gamma_SC (:,:,:,:), & & Charge_dens (:), k1_trap , k2_actual , Delta_local , Charge_dens_local ) Delta_sum (:,:,:,:) = Delta_sum (:,:,:,:) + Delta_local (:,:,:,:) Charge_dens_sum (:) = Charge_dens_sum (:) + Charge_dens_local (:) ! Delta_iterations(:,:,:,:,j) =  Delta_iterations(:,:,:,:,j) + Delta_local(:,:,:,:) ! Charge_dens_iterations(:,j) = Charge_dens_iterations(:,j) + Charge_dens_local(:) k1_trap = k1_trap + dk1_trap END DO Delta_iterations (:,:,:,:, j ) = 0.5 * ( Delta_iterations (:,:,:,:, j ) + ( k1_chunk_max - k1_chunk_min ) * Delta_sum (:,:,:,:) / i ) Charge_dens_iterations (:, j ) = 0.5 * ( Charge_dens_iterations (:, j ) + ( k1_chunk_max - k1_chunk_min ) * Charge_dens_sum (:) / i ) !!!!!!!! THIS PART COULD LEAD TO A PROBLEM !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Delta_iterations(:,:,:,:,j) = 0.5*(k1_chunk_max - k1_chunk_min)/i * Delta_iterations(:,:,:,:,j) ! Charge_dens_iterations(:,j) = 0.5*(k1_chunk_max - k1_chunk_min)/i * Charge_dens_iterations(:,j) !Summing all previously calculated values !They were calculated in different points ! DO n = 1, j !     Delta_iterations(:,:,:,:,j) =  Delta_iterations(:,:,:,:,j) + 0.5*Delta_iterations(:,:,:,:,n) !     Charge_dens_iterations(:,j) = Charge_dens_iterations(:,j) + 0.5*Charge_dens_iterations(:,n) ! END DO !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! IF ( j >= interpolation_deg_x ) THEN !For all components of Delta_iterations and Charge_dens_iterations !Check whether integral when dk1 ---> 0 can be approximated !With relative error no bigger than EPS convergence = . TRUE . !Checking Delta_iterations convergence DO spin = 1 , 2 DO orb = 1 , ORBITALS DO n = 1 , N_ALL_NEIGHBOURS DO lat = 1 , SUBLATTICES CALL POLINT ( stepsize (( j - interpolation_deg_x + 1 ): j ), Delta_iterations ( orb , n , spin , lat ,( j - interpolation_deg_x + 1 ): j ), & & interpolation_deg_x , DCMPLX ( 0. , 0. ), result , result_error ) Delta_local ( orb , n , spin , lat ) = result IF ( ABS ( result_error ) > romb_eps_x * ABS ( result )) THEN convergence = . FALSE . END IF END DO END DO END DO END DO !Chaecking Charge_dens convergence DO n = 1 , DIM_POSITIVE_K CALL POLINT ( stepsize (( j - interpolation_deg_x + 1 ): j ), DCMPLX ( Charge_dens_iterations ( n ,( j - interpolation_deg_x + 1 ): j ), 0. ), & & interpolation_deg_x , DCMPLX ( 0. , 0. ), result , result_error ) Charge_dens_local ( n ) = REAL ( result ) IF ( ABS ( result_error ) > romb_eps_x * ABS ( result )) THEN convergence = . FALSE . END IF END DO END IF END IF IF ( convergence ) THEN RETURN ELSE Delta_iterations (:,:,:,:, j + 1 ) = Delta_iterations (:,:,:,:, j ) Charge_dens_iterations (:, j + 1 ) = Charge_dens_iterations (:, j ) stepsize ( j + 1 ) = 0.25 * stepsize ( j ) END IF END DO END SUBROUTINE ROMBERG_X !See Section 3.1 SUBROUTINE POLINT ( X , Y , deg , x_target , y_approx , dy ) INTEGER * 4 , INTENT ( IN ) :: deg COMPLEX * 16 , INTENT ( IN ) :: X ( deg ), Y ( deg ), x_target COMPLEX * 16 , INTENT ( OUT ) :: y_approx , dy INTEGER * 4 :: i , m , nearest COMPLEX * 16 :: dx_left , dx_right , w , den REAL * 8 :: diff , diff_temp COMPLEX * 16 :: C ( deg ), D ( deg ) nearest = 1 diff = ABS ( x_target - X ( 1 )) !Finding tabulated X closest to x_target DO i = 1 , nearest diff_temp = ABS ( x_target - X ( i )) IF ( diff_temp < diff ) THEN diff = diff_temp nearest = i END IF END DO !Initializing C and D values C (:) = Y (:) D (:) = Y (:) y_approx = Y ( nearest ) nearest = nearest - 1 DO m = 1 , deg - 1 DO i = 1 , deg - m dx_left = X ( i ) - x_target dx_right = X ( i + m ) - x_target w = C ( i + 1 ) - D ( i ) den = dx_left - dx_right IF ( den == 0 ) STOP 'Repeating values in X table' den = w / den D ( i ) = dx_right * den C ( i ) = dx_left * den END DO IF ( 2 * nearest < deg - m ) THEN dy = C ( nearest + 1 ) ELSE dy = D ( nearest ) nearest = nearest - 1 END IF y_approx = y_approx + dy END DO END SUBROUTINE ! !See section 4.3 ! !Romberg integration ! SUBROUTINE QROMB(func, x_min, x_max, result) !     COMPLEX*16, INTENT(IN) :: x_min, x_max !     COMPLEX*16, EXTERNAL :: func !     COMPLEX*16, INTENT(OUT) :: result !     REAL*8, PARAMETER :: EPS = 1e-6 !     INTEGER*4, PARAMETER :: JMAX = 20 !     INTEGER*4, PARAMETER :: K = 5 !     COMPLEX*16 :: stepsize(JMAX + 1), integral(JMAX + 1) !     COMPLEX*16 :: result_error !     INTEGER*4 :: j !     stepsize(1) = 1. !     !Maximum number of splittings to half !     DO j = 1, JMAX !         CALL TRAPZD(func, x_min, x_max, integral(j), j) !         IF (j >= K) THEN !             !Really smart - based on previous iterations we want to extrapolate value of integral when stepsize would be 0. !             !Passing last K steps !             CALL POLINT(stepsize(j - K + 1), integral(j - K + 1), K, DCMPLX(0. , 0.), result, result_error) !             IF (ABS(result_error) < EPS*ABS(result)) RETURN !         END IF !         integral(j + 1) = integral(j) !         stepsize(j+1) = 0.25*stepsize(j)    !This is crucial !     END DO ! END SUBROUTINE QROMB ! !See Section 4.2 ! !Extended trapezoidal rule ! SUBROUTINE TRAPZD(func, x_min, x_max, result, n) !     COMPLEX*16, INTENT(IN) :: x_max, x_min !     INTEGER*4, INTENT(IN) :: n !     COMPLEX*16, INTENT(OUT) :: result !     COMPLEX*16, EXTERNAL :: func !     INTEGER*4 :: i,j !     COMPLEX*16 :: dx, x, sum !     !First approximation of integral !     IF (n == 1) THEN !         result = 0.5*(x_max - x_min)*(func(x_min) + func(x_max)) !     ELSE !         i = 2**(n-2) !         dx = (x_max  - x_min)/i !         x = x_min + 0.5*dx !         sum = 0. !         DO j = 1, i !             sum = sum + func(x) !             x = x + dx !         END DO !         result = 0.5*(result + (x_max - x_min)*sum/i) !     END IF ! END SUBROUTINE TRAPZD END MODULE mod_integrate","tags":"","loc":"sourcefile/mod_integrate.f90.html"},{"title":"main_postprocessing.f90 – Fortran Program","text":"Source Code PROGRAM main_postprocessing USE mod_hamiltonians USE mod_parameters USE mod_utilities USE mod_writers USE mod_reader USE mod_compute_hamiltonians USE mod_postprocessing IMPLICIT NONE REAL * 8 :: zeta INTEGER * 4 :: Nk , HamDim zeta = 1e-5 Nk = 5000 HamDim = DIM !CALL CALCULATE_DISPERSION(\"Energies.dat\") !CALL CALCULATE_DOS(-1.2e3*meV2au, -0.8e3*meV2au, 0.1*meV2au, zeta, \"OutputData/DOS.dat\") CALL CALCULATE_CHERN_PARAMS ( Nk , Nk , HamDim ) END PROGRAM main_postprocessing","tags":"","loc":"sourcefile/main_postprocessing.f90.html"},{"title":"mod_broydenV2.f90 – Fortran Program","text":"Source Code MODULE mod_broydenV2 CONTAINS ! Copyright (C) 2010-2016 Samuel Ponce', Roxana Margine, Carla Verdi, Feliciano Giustino ! ! This file is distributed under the terms of the GNU General Public ! License. See the file `LICENSE' in the root directory of the ! present distribution, or http://www.gnu.org/copyleft.gpl.txt . ! ! Adapted from QE ! !----------------------------------------------------------------------- SUBROUTINE mix_broyden ( ndim , deltaout , deltain , alphamix , iter , n_iter , conv ) !----------------------------------------------------------------------- !! !! Modified Broyden's method for potential/charge density mixing !!             D.D.Johnson, PRB 38, 12807 (1988) !! ! !USE constants_epw, ONLY : DP !USE mod_indata, ONLY : nsiter ! IMPLICIT NONE ! LOGICAL , INTENT ( in ) :: conv !! If true convergence reache INTEGER , INTENT ( in ) :: ndim !! Dimension of arrays deltaout, deltain INTEGER , INTENT ( in ) :: iter !! Current iteration number INTEGER , INTENT ( in ) :: n_iter !! Number of iterations used in the mixing REAL * 8 , INTENT ( in ) :: alphamix !! Mixing factor (0 < alphamix <= 1) REAL * 8 , INTENT ( inout ) :: deltaout ( ndim ) !! output Delta at current iteration REAL * 8 , INTENT ( inout ) :: deltain ( ndim ) !! Delta at previous iteration !   Here the local variables ! max number of iterations used in mixing: n_iter must be .le. maxter INTEGER * 4 , PARAMETER :: maxter = 8 ! INTEGER * 4 :: n , i , j , iwork ( maxter ), info , iter_used , ipos , inext ! work space containing info from previous iterations: ! must be kept in memory and saved between calls REAL * 8 , ALLOCATABLE , SAVE :: df (:,:), dv (:,:) REAL * 8 , ALLOCATABLE :: deltainsave (:) REAL * 8 :: beta ( maxter , maxter ), gammamix , work ( maxter ), norm REAL * 8 , EXTERNAL :: DDOT , DNRM2 ! adjustable PARAMETERs as suggested in the original paper REAL * 8 wg ( maxter ), wg0 DATA wg0 / 0.01d0 / , wg / maxter * 1.d0 / !IF ( iter .lt. 1 ) print *, 'mix_broyden','n_iter is smaller than 1' !IF ( n_iter .gt. maxter ) print *, 'mix_broyden','n_iter is too big' !IF ( ndim .le. 0 ) print *, 'mix_broyden','ndim .le. 0' IF ( iter . eq . 1 ) THEN IF ( . not . ALLOCATED ( df ) ) ALLOCATE ( df ( ndim , n_iter ) ) IF ( . not . ALLOCATED ( dv ) ) ALLOCATE ( dv ( ndim , n_iter ) ) ENDIF IF ( conv ) THEN IF ( ALLOCATED ( df ) ) DEALLOCATE ( df ) IF ( ALLOCATED ( dv ) ) DEALLOCATE ( dv ) RETURN ENDIF IF ( . not . ALLOCATED ( deltainsave ) ) ALLOCATE ( deltainsave ( ndim ) ) deltainsave (:) = deltain (:) ! ! iter_used = iter-1  IF iter <= n_iter ! iter_used = n_iter  IF iter >  n_iter ! iter_used = min ( iter - 1 , n_iter ) ! ! ipos is the position in which results from the present iteraction ! are stored. ipos=iter-1 until ipos=n_iter, THEN back to 1,2,... ! ipos = iter - 1 - ( ( iter - 2 ) / n_iter ) * n_iter ! DO n = 1 , ndim deltaout ( n ) = deltaout ( n ) - deltain ( n ) ENDDO ! IF ( iter . gt . 1 ) THEN DO n = 1 , ndim df ( n , ipos ) = deltaout ( n ) - df ( n , ipos ) dv ( n , ipos ) = deltain ( n ) - dv ( n , ipos ) ENDDO norm = ( DNRM2 ( ndim , df ( 1 , ipos ), 1 ) ) ** 2.d0 norm = sqrt ( norm ) CALL DSCAL ( ndim , 1.d0 / norm , df ( 1 , ipos ), 1 ) CALL DSCAL ( ndim , 1.d0 / norm , dv ( 1 , ipos ), 1 ) ENDIF ! DO i = 1 , iter_used DO j = i + 1 , iter_used beta ( i , j ) = wg ( i ) * wg ( j ) * DDOT ( ndim , df ( 1 , j ), 1 , df ( 1 , i ), 1 ) ENDDO beta ( i , i ) = wg0 ** 2.d0 + wg ( i ) ** 2.d0 ENDDO ! ! DSYTRF computes the factorization of a real symmetric matrix ! CALL DSYTRF ( 'U' , iter_used , beta , maxter , iwork , work , maxter , info ) !print *, \"Broyden factorization\", info ! ! DSYTRI computes the inverse of a real symmetric indefinite matrix ! CALL DSYTRI ( 'U' , iter_used , beta , maxter , iwork , work , info ) !print *, \"broyden DSYTRI\", info ! DO i = 1 , iter_used DO j = i + 1 , iter_used beta ( j , i ) = beta ( i , j ) ENDDO ENDDO ! DO i = 1 , iter_used work ( i ) = DDOT ( ndim , df ( 1 , i ), 1 , deltaout , 1 ) ENDDO ! DO n = 1 , ndim deltain ( n ) = deltain ( n ) + alphamix * deltaout ( n ) ENDDO ! DO i = 1 , iter_used gammamix = 0.d0 DO j = 1 , iter_used gammamix = gammamix + beta ( j , i ) * wg ( j ) * work ( j ) ENDDO ! DO n = 1 , ndim deltain ( n ) = deltain ( n ) - wg ( i ) * gammamix * ( alphamix * df ( n , i ) + dv ( n , i ) ) ENDDO ENDDO ! inext = iter - ( ( iter - 1 ) / n_iter ) * n_iter df (:, inext ) = deltaout (:) dv (:, inext ) = deltainsave (:) ! IF ( ALLOCATED ( deltainsave ) ) DEALLOCATE ( deltainsave ) ! RETURN ! END SUBROUTINE mix_broyden ! END MODULE mod_broydenV2","tags":"","loc":"sourcefile/mod_broydenv2.f90.html"},{"title":"mod_utilities.f90 – Fortran Program","text":"Source Code MODULE mod_utilities USE mod_parameters USE mod_reader IMPLICIT NONE CONTAINS SUBROUTINE DIAGONALIZE_HERMITIAN ( Hamiltonian , Eigenvalues , N ) IMPLICIT NONE INTEGER * 4 , INTENT ( IN ) :: N COMPLEX * 16 , INTENT ( INOUT ) :: Hamiltonian ( N , N ) REAL * 8 , INTENT ( OUT ) :: Eigenvalues ( N ) COMPLEX * 16 , ALLOCATABLE :: WORK (:) REAL * 8 , ALLOCATABLE :: RWORK (:) INTEGER * 4 :: LWORK INTEGER * 4 :: INFO LWORK = 10 * DIM ALLOCATE ( WORK ( LWORK )) ALLOCATE ( RWORK ( 3 * N - 2 )) CALL ZHEEV ( 'V' , 'U' , N , Hamiltonian , N , Eigenvalues , WORK , LWORK , RWORK , INFO ) !WRITE(*, fmt = \"(15F10.4)\") Eigenvalues IF ( INFO . ne . 0 ) THEN PRINT * , 'ZHEEV INFO ' , INFO STOP END IF DEALLOCATE ( WORK ) DEALLOCATE ( RWORK ) END SUBROUTINE DIAGONALIZE_HERMITIAN SUBROUTINE DIAGONALIZE_GENERALIZED ( Hamiltonian , Eigenvalues , U_transformation , N ) IMPLICIT NONE INTEGER * 4 , INTENT ( IN ) :: N COMPLEX * 16 , INTENT ( INOUT ) :: Hamiltonian ( N , N ) COMPLEX * 16 , INTENT ( INOUT ) :: U_transformation ( N , N ) REAL * 8 , INTENT ( OUT ) :: Eigenvalues ( N ) COMPLEX * 16 , ALLOCATABLE :: W (:) COMPLEX * 16 , ALLOCATABLE :: VL (:,:) COMPLEX * 16 , ALLOCATABLE :: WORK (:) REAL * 8 , ALLOCATABLE :: RWORK (:) INTEGER * 4 :: LWORK INTEGER * 4 :: INFO LWORK = 10 * N INFO = 0 ALLOCATE ( W ( N )) ALLOCATE ( VL ( N , N )) ALLOCATE ( WORK ( LWORK )) ALLOCATE ( RWORK ( 2 * N )) W (:) = 0. VL (:,:) = DCMPLX ( 0. , 0. ) WORK (:) = 0. RWORK (:) = 0. CALL ZGEEV ( 'N' , 'V' , N , Hamiltonian , N , W , VL , N , U_transformation , N ,& & WORK , LWORK , RWORK , INFO ) IF ( INFO . ne . 0 ) THEN PRINT * , 'ZGEEV INFO ' , INFO STOP END IF Eigenvalues (:) = REAL ( W (:)) DEALLOCATE ( W ) DEALLOCATE ( VL ) DEALLOCATE ( WORK ) DEALLOCATE ( RWORK ) END SUBROUTINE DIAGONALIZE_GENERALIZED SUBROUTINE COMPUTE_CONJUGATE_ELEMENTS ( Hamiltonian , N ) IMPLICIT NONE INTEGER * 4 , INTENT ( IN ) :: N COMPLEX * 16 , INTENT ( INOUT ) :: Hamiltonian ( N , N ) INTEGER * 4 :: i , j DO i = 1 , N DO j = i + 1 , N Hamiltonian ( j , i ) = CONJG ( Hamiltonian ( i , j )) END DO END DO END SUBROUTINE COMPUTE_CONJUGATE_ELEMENTS !dir$ attributes forceinline :: epsilon_yz PURE COMPLEX * 16 FUNCTION epsilon_yz ( kx , ky ) REAL * 8 , INTENT ( IN ) :: kx , ky epsilon_yz = - t_D * ( 1. + EXP ( imag * ( SQRT ( 3. ) / 2. * kx - 3. / 2. * ky ))) & - t_I * EXP ( - imag * ( SQRT ( 3. ) / 2. * kx + 3. / 2. * ky )) RETURN END FUNCTION epsilon_yz !dir$ attributes forceinline :: epsilon_zx PURE COMPLEX * 16 FUNCTION epsilon_zx ( kx , ky ) REAL * 8 , INTENT ( IN ) :: kx , ky epsilon_zx = - t_D * ( 1. + EXP ( - imag * ( SQRT ( 3. ) / 2. * kx + 3. / 2. * ky ))) & - t_I * EXP ( imag * ( SQRT ( 3. ) / 2. * kx - 3. / 2. * ky )) RETURN END FUNCTION epsilon_zx !dir$ attributes forceinline :: epsilon_xy PURE COMPLEX * 16 FUNCTION epsilon_xy ( kx , ky ) REAL * 8 , INTENT ( IN ) :: kx , ky epsilon_xy = - 2. * t_D * DCOS ( SQRT ( 3. ) / 2. * kx ) * EXP ( - imag * 3. / 2. * ky ) - t_I RETURN END FUNCTION epsilon_xy !dir$ attributes forceinline :: pairing_1 PURE COMPLEX * 16 FUNCTION pairing_1 ( ky ) REAL * 8 , INTENT ( IN ) :: ky pairing_1 = EXP ( imag * ky ) RETURN END FUNCTION pairing_1 !dir$ attributes forceinline :: pairing_2 PURE COMPLEX * 16 FUNCTION pairing_2 ( kx , ky ) REAL * 8 , INTENT ( IN ) :: kx , ky pairing_2 = EXP ( - imag * ( SQRT ( 3. ) / 2. * kx + ky / 2. )) RETURN END FUNCTION pairing_2 !dir$ attributes forceinline :: pairing_3 PURE COMPLEX * 16 FUNCTION pairing_3 ( kx , ky ) REAL * 8 , INTENT ( IN ) :: kx , ky pairing_3 = EXP ( - imag * ( - SQRT ( 3. ) / 2. * kx + ky / 2. )) RETURN END FUNCTION pairing_3 !dir$ attributes forceinline :: pairing_nnn_1 PURE COMPLEX * 16 FUNCTION pairing_nnn_1 ( kx ) REAL * 8 , INTENT ( IN ) :: kx pairing_nnn_1 = EXP ( - imag * ( SQRT ( 3. ) * kx )) RETURN END FUNCTION pairing_nnn_1 !dir$ attributes forceinline :: pairing_nnn_2 PURE COMPLEX * 16 FUNCTION pairing_nnn_2 ( kx , ky ) REAL * 8 , INTENT ( IN ) :: kx , ky pairing_nnn_2 = EXP ( - imag * ( 3. * SQRT ( 3. ) / 2. * kx + 3. / 2. * ky )) RETURN END FUNCTION pairing_nnn_2 !dir$ attributes forceinline :: pairing_nnn_3 PURE COMPLEX * 16 FUNCTION pairing_nnn_3 ( kx , ky ) REAL * 8 , INTENT ( IN ) :: kx , ky pairing_nnn_3 = EXP ( - imag * ( - SQRT ( 3. ) / 2. * kx + 3. / 2. * ky )) RETURN END FUNCTION pairing_nnn_3 !dir$ attributes forceinline :: pairing_nnn_4 PURE COMPLEX * 16 FUNCTION pairing_nnn_4 ( kx ) REAL * 8 , INTENT ( IN ) :: kx pairing_nnn_4 = EXP ( - imag * ( - SQRT ( 3. ) * kx )) RETURN END FUNCTION pairing_nnn_4 !dir$ attributes forceinline :: pairing_nnn_5 PURE COMPLEX * 16 FUNCTION pairing_nnn_5 ( kx , ky ) REAL * 8 , INTENT ( IN ) :: kx , ky pairing_nnn_5 = EXP ( - imag * ( - SQRT ( 3. ) / 2. * kx - 3. / 2. * ky )) RETURN END FUNCTION pairing_nnn_5 !dir$ attributes forceinline :: pairing_nnn_6 PURE COMPLEX * 16 FUNCTION pairing_nnn_6 ( kx , ky ) REAL * 8 , INTENT ( IN ) :: kx , ky pairing_nnn_6 = EXP ( - imag * ( SQRT ( 3. ) / 2. * kx - 3. / 2. * ky )) RETURN END FUNCTION pairing_nnn_6 !dir$ attributes forceinline :: fd_distribution PURE REAL * 8 FUNCTION fd_distribution ( E , E_Fermi , T ) IMPLICIT NONE REAL * 8 , INTENT ( IN ) :: E , E_Fermi , T IF ( T . ne . 0 ) THEN fd_distribution = 1. / ( EXP (( E - E_Fermi ) / ( k_B * T )) + 1. ) ELSE IF ( E > E_Fermi ) THEN fd_distribution = 0. ELSE IF ( E == E_Fermi ) THEN fd_distribution = 0.5 ELSE IF ( E < E_Fermi ) THEN fd_distribution = 1. END IF END IF RETURN END FUNCTION fd_distribution !dir$ attributes forceinline :: dirac_delta REAL * 8 FUNCTION dirac_delta ( E , omega , zeta ) IMPLICIT NONE REAL * 8 , INTENT ( IN ) :: E , omega , zeta dirac_delta = zeta / ( PI * (( E - omega ) ** 2 + zeta ** 2 )) RETURN END FUNCTION dirac_delta REAL * 8 FUNCTION meV_to_au ( x ) IMPLICIT NONE REAL * 8 :: x meV_to_au = x / 2721 1. RETURN END FUNCTION meV_to_au REAL * 8 FUNCTION nm_to_au ( x ) IMPLICIT NONE REAL * 8 :: x nm_to_au = x / 0.05292 RETURN END FUNCTION nm_to_au REAL * 8 FUNCTION au_to_meV ( x ) IMPLICIT NONE REAL * 8 :: x au_to_meV = x * 27211 RETURN END FUNCTION au_to_meV REAL * 8 FUNCTION au_to_nm ( x ) IMPLICIT NONE REAL * 8 :: x au_to_nm = x * 0.05292 RETURN END FUNCTION au_to_nm END MODULE mod_utilities","tags":"","loc":"sourcefile/mod_utilities.f90.html"},{"title":"mod_writers.f90 – Fortran Program","text":"Source Code MODULE mod_writers USE mod_parameters IMPLICIT NONE CONTAINS SUBROUTINE PRINT_HAMILTONIAN ( Hamiltonian ) COMPLEX * 16 , INTENT ( IN ) :: Hamiltonian ( DIM , DIM ) CHARACTER ( LEN = 20 ) :: output_format INTEGER * 4 :: i WRITE ( output_format , '(A, I0, A)' ) '(' , DIM , 'E15.5)' output_format = TRIM ( output_format ) OPEN ( unit = 9 , FILE = \"./OutputData/H_real.dat\" , FORM = \"FORMATTED\" , ACTION = \"WRITE\" ) OPEN ( unit = 10 , FILE = \"./OutputData/H_imag.dat\" , FORM = \"FORMATTED\" , ACTION = \"WRITE\" ) DO i = 1 , DIM WRITE ( 9 , output_format ) REAL ( Hamiltonian ( i ,:)) WRITE ( 10 , output_format ) AIMAG ( Hamiltonian ( i ,:)) END DO CLOSE ( 9 ) CLOSE ( 10 ) END SUBROUTINE PRINT_HAMILTONIAN SUBROUTINE PRINT_ENERGIES ( Energies , k1_steps , k2_steps , dk1 , dk2 , filename , N ) INTEGER * 4 , INTENT ( IN ) :: N REAL * 8 , INTENT ( IN ) :: Energies ( 0 : k1_steps , 0 : k2_steps , N ) REAL * 8 , INTENT ( IN ) :: dk1 , dk2 INTEGER * 4 , INTENT ( IN ) :: k1_steps , k2_steps REAL * 8 :: k1 , k2 , kx , ky CHARACTER ( LEN =* ), INTENT ( IN ) :: filename CHARACTER ( LEN = 20 ) :: output_format INTEGER * 4 :: i , j , l output_format = '(I5, 3E15.5)' OPEN ( unit = 9 , FILE = \"./OutputData/\" // filename // \".dat\" , FORM = \"FORMATTED\" , ACTION = \"WRITE\" ) DO l = 1 , N DO i = 0 , k1_steps DO j = 0 , k2_steps k1 = i * dk1 k2 = j * dk2 kx = 2. * PI / ( SQRT ( 3.0d0 )) * k1 ky = - 2. * PI / 3. * k1 + 4. * PI / 3. * k2 WRITE ( 9 , output_format ) l , k1 , k2 , Energies ( i , j , l ) / meV2au END DO WRITE ( 9 , * ) WRITE ( 9 , * ) END DO WRITE ( 9 , * ) WRITE ( 9 , * ) END DO CLOSE ( 9 ) END SUBROUTINE SUBROUTINE PRINT_GAMMA ( Gamma_SC , filename ) COMPLEX * 16 , INTENT ( IN ) :: Gamma_SC ( ORBITALS , N_ALL_NEIGHBOURS , 2 , SUBLATTICES ) CHARACTER ( LEN =* ), INTENT ( IN ) :: filename CHARACTER ( LEN = 20 ) :: output_format INTEGER * 4 :: orb , j , spin , lat output_format = '(4I5, 2E15.5)' !Printing SC gammas in [meV] OPEN ( unit = 9 , FILE = \"./OutputData/\" // filename // \".dat\" , FORM = \"FORMATTED\" , ACTION = \"WRITE\" ) WRITE ( 9 , * ) \"#spin neighbour lattice orbital Re(Gamma) Im(Gamma)\" DO spin = 1 , 2 DO j = 1 , N_ALL_NEIGHBOURS DO lat = 1 , SUBLATTICES DO orb = 1 , ORBITALS WRITE ( 9 , output_format ) spin , j , lat , orb , REAL ( Gamma_SC ( orb , j , spin , lat )) / meV2au , AIMAG ( Gamma_SC ( orb , j , spin , lat )) / meV2au END DO END DO WRITE ( 9 , * ) WRITE ( 9 , * ) END DO END DO CLOSE ( 9 ) END SUBROUTINE PRINT_GAMMA SUBROUTINE PRINT_CHARGE ( Charge_dens , filename ) REAL * 8 , INTENT ( IN ) :: Charge_dens ( DIM_POSITIVE_K ) CHARACTER ( LEN =* ), INTENT ( IN ) :: filename CHARACTER ( LEN = 20 ) :: output_format INTEGER * 4 :: spin , lat , orb , n output_format = '(3I5, 1E15.5)' n = 1 OPEN ( unit = 9 , FILE = \"./OutputData/\" // filename // \".dat\" , FORM = \"FORMATTED\" , ACTION = \"WRITE\" ) WRITE ( 9 , * ) \"#spin lattice orbital Charge\" DO spin = 1 , 2 DO lat = 1 , SUBLATTICES DO orb = 1 , ORBITALS WRITE ( 9 , output_format ) spin , lat , orb , Charge_dens ( n ) n = n + 1 END DO END DO END DO CLOSE ( 9 ) END SUBROUTINE PRINT_CHARGE END MODULE mod_writers","tags":"","loc":"sourcefile/mod_writers.f90.html"},{"title":"mod_postprocessing.f90 – Fortran Program","text":"Source Code MODULE mod_postprocessing USE mod_hamiltonians USE mod_parameters USE mod_utilities USE mod_writers USE mod_reader USE mod_compute_hamiltonians IMPLICIT NONE CONTAINS SUBROUTINE CALCULATE_DOS ( E_DOS_min , E_DOS_max , dE0 , zeta_DOS , DOS_filename ) !DOS calculation REAL * 8 , INTENT ( IN ) :: E_DOS_min , E_DOS_max , dE0 REAL * 8 , INTENT ( IN ) :: zeta_DOS CHARACTER ( LEN =* ), INTENT ( IN ) :: DOS_filename REAL * 8 :: E0 INTEGER * 4 :: DOS_steps COMPLEX * 16 , ALLOCATABLE :: Hamiltonian (:,:), Hamiltonian_const (:,:), U_transformation (:,:) REAL * 8 , ALLOCATABLE :: Energies (:,:,:) COMPLEX * 16 , ALLOCATABLE :: Gamma_SC (:,:,:,:) REAL * 8 , ALLOCATABLE :: Charge_dens (:) REAL * 8 , ALLOCATABLE :: DOS (:) CHARACTER ( LEN = 20 ) :: output_format REAL * 8 :: k1 , k2 , kx , ky INTEGER * 4 :: i , j , k , n , lat , orb , orb_prime , spin ! E_DOS_MIN = E_DOS_min * meV2au ! E_DOS_max = E_DOS_max * meV2au ! dE0 = dE0 * meV2au DOS_steps = INT (( E_DOS_max - E_DOS_min ) / dE0 ) PRINT * , E_DOS_min , E_DOS_min , dE0 PRINT * , zeta_DOS PRINT * , DOS_filename !PRINT*, \"READING INPUT\" CALL GET_INPUT ( \"dispersion_input.nml\" ) ALLOCATE ( Hamiltonian ( DIM , DIM )) ALLOCATE ( Hamiltonian_const ( DIM , DIM )) ALLOCATE ( U_transformation ( DIM_POSITIVE_K , DIM_POSITIVE_K )) ALLOCATE ( Energies ( 0 : k1_steps , 0 : k2_steps , DIM_POSITIVE_K )) ALLOCATE ( Gamma_SC ( ORBITALS , N_ALL_NEIGHBOURS , 2 , SUBLATTICES )) ALLOCATE ( Charge_dens ( DIM_POSITIVE_K )) ALLOCATE ( DOS ( 0 : DOS_steps )) Hamiltonian (:,:) = DCMPLX ( 0. , 0. ) Hamiltonian_const (:,:) = DCMPLX ( 0. , 0. ) Energies (:,:,:) = 0. Gamma_SC (:,:,:,:) = DCMPLX ( 0. , 0. ) * meV2au Charge_dens (:) = 0. !Get self consistent gamma and charge density !CALL GET_GAMMA_SC(Gamma_SC(:,:,:,:), \"OutputData/Gamma_SC_iter.dat\") CALL GET_CHARGE_DENS ( Charge_dens (:), \"/home/jczarnecki/LAO-STO-results/RUNS_low_U/RUN_E_Fermi_-905.0_U_HUB_166.66666666666666_V_HUB_166.66666666666666/OutputData/Chargen_dens_final.dat\" ) !Computing k-independent terms CALL COMPUTE_TRIGONAL_TERMS ( Hamiltonian_const (:,:)) CALL COMPUTE_ATOMIC_SOC_TERMS ( Hamiltonian_const (:,:)) CALL COMPUTE_ELECTRIC_FIELD ( Hamiltonian_const (:,:)) DO n = 1 , DIM_POSITIVE_K Hamiltonian_const ( n , n ) = Hamiltonian_const ( n , n ) - E_Fermi Hamiltonian_const ( DIM_POSITIVE_K + n , DIM_POSITIVE_K + n ) = Hamiltonian_const ( DIM_POSITIVE_K + n , DIM_POSITIVE_K + n ) + E_Fermi END DO CALL COMPUTE_CONJUGATE_ELEMENTS ( Hamiltonian_const (:,:), DIM ) !This is not needed, since ZHEEV takes only upper triangle DO i = 0 , k1_steps DO j = 0 , k2_steps k1 = i * dk1 k2 = j * dk2 kx = 2. * PI / ( SQRT ( 3.0d0 )) * k1 ky = - 2. * PI / 3. * k1 + 4. * PI / 3. * k2 Hamiltonian (:,:) = DCMPLX ( 0. , 0. ) CALL COMPUTE_TBA_TERM ( Hamiltonian (:,:), kx , ky ) CALL COMPUTE_TI1_TI2 ( Hamiltonian (:,:), kx , ky ) !There may be a problem since Ti1,Ti2 coupling is assumed to be equal Ti2,Ti1 CALL COMPUTE_H_PI ( Hamiltonian (:,:), kx , ky ) !There may be a problem since Ti1,Ti2 coupling is assumed to be equal Ti2,Ti1 CALL COMPUTE_H_SIGMA ( Hamiltonian (:,:), kx , ky ) !There may be a problem since Ti1,Ti2 coupling is assumed to be equal Ti2,Ti1 CALL COMPUTE_HUBBARD ( Hamiltonian (:,:), Charge_dens (:)) CALL COMPUTE_SC ( Hamiltonian (:,:), kx , ky , Gamma_SC (:,:,:,:)) CALL COMPUTE_CONJUGATE_ELEMENTS ( Hamiltonian (:,:), DIM ) !This is not needed, since ZHEEV takes only upper triangle Hamiltonian (:,:) = Hamiltonian_const (:,:) + Hamiltonian (:,:) !Should by multiplied by 0.5 if in Nambu space CALL DIAGONALIZE_GENERALIZED ( Hamiltonian (: DIM_POSITIVE_K ,: DIM_POSITIVE_K ), Energies ( i , j ,:), U_transformation (:,:), DIM_POSITIVE_K ) END DO END DO DO n = 0 , DOS_steps DO i = 0 , k1_steps DO j = 0 , k2_steps DO k = 1 , DIM_POSITIVE_K E0 = E_DOS_min + n * dE0 DOS ( n ) = DOS ( n ) + dirac_delta ( Energies ( i , j , k ), E0 , zeta_DOS ) END DO END DO END DO END DO output_format = '(2E15.5)' OPEN ( unit = 9 , FILE = TRIM ( DOS_filename ), FORM = \"FORMATTED\" , ACTION = \"WRITE\" ) WRITE ( 9 , '(A)' ) \"#E[meV] DOS[a.u]\" DO n = 0 , DOS_steps E0 = E_DOS_min + n * dE0 WRITE ( 9 , output_format ) E0 / meV2au , DOS ( n ) END DO CLOSE ( 9 ) DEALLOCATE ( Hamiltonian ) DEALLOCATE ( Hamiltonian_const ) DEALLOCATE ( U_transformation ) DEALLOCATE ( Energies ) DEALLOCATE ( Gamma_SC ) DEALLOCATE ( Charge_dens ) DEALLOCATE ( DOS ) END SUBROUTINE CALCULATE_DOS SUBROUTINE CALCULATE_DISPERSION ( filename ) CHARACTER ( LEN =* ), INTENT ( IN ) :: filename CHARACTER ( LEN = 20 ) :: output_format COMPLEX * 16 , ALLOCATABLE :: Hamiltonian (:,:), Hamiltonian_const (:,:), U_transformation (:,:) REAL * 8 , ALLOCATABLE :: Energies (:,:,:) REAL * 8 , ALLOCATABLE :: Probability (:,:,:,:) ! |Psi&#94;2| COMPLEX * 16 , ALLOCATABLE :: Gamma_SC (:,:,:,:) REAL * 8 , ALLOCATABLE :: Charge_dens (:) REAL * 8 , ALLOCATABLE :: DOS (:) REAL * 8 :: k1 , k2 , kx , ky INTEGER * 4 :: i , j , k , n , lat , orb , orb_prime , spin , l , m INTEGER * 4 :: kx_steps , ky_steps REAL * 8 :: yz_contribution , zx_contribution , xy_contribution REAL * 8 :: lat1_contribution , lat2_contribution REAL * 8 :: spin_up_contribution , spin_down_contribution !PRINT*, \"READING INPUT\" CALL GET_INPUT ( \"dispersion_input.nml\" ) yz_contribution = 0. zx_contribution = 0. xy_contribution = 0. lat1_contribution = 0. lat2_contribution = 0. spin_up_contribution = 0. spin_down_contribution = 0. kx_steps = INT ( k1_steps / 2 ) ky_steps = INT ( k2_steps / 2 ) output_format = '(I5, 10E15.5)' ALLOCATE ( Hamiltonian ( DIM , DIM )) ALLOCATE ( Hamiltonian_const ( DIM , DIM )) ALLOCATE ( U_transformation ( DIM_POSITIVE_K , DIM_POSITIVE_K )) ALLOCATE ( Probability ( - kx_steps : kx_steps , - ky_steps : ky_steps , DIM_POSITIVE_K , DIM_POSITIVE_K )) ALLOCATE ( Energies ( - kx_steps : kx_steps , - ky_steps : ky_steps , DIM_POSITIVE_K )) ALLOCATE ( Gamma_SC ( ORBITALS , N_ALL_NEIGHBOURS , 2 , SUBLATTICES )) ALLOCATE ( Charge_dens ( DIM_POSITIVE_K )) Hamiltonian (:,:) = DCMPLX ( 0. , 0. ) Hamiltonian_const (:,:) = DCMPLX ( 0. , 0. ) Probability (:,:,:,:) = 0. Energies (:,:,:) = 0. Gamma_SC (:,:,:,:) = DCMPLX ( 0. , 0. ) * meV2au Charge_dens (:) = 0. CALL GET_CHARGE_DENS ( Charge_dens (:), \"/home/jczarnecki/LAO-STO-results/RUNS_low_U/RUN_E_Fermi_-905.0_U_HUB_166.66666666666666_V_HUB_166.66666666666666/OutputData/Chargen_dens_final.dat\" ) !Computing k-independent terms CALL COMPUTE_TRIGONAL_TERMS ( Hamiltonian_const (:,:)) CALL COMPUTE_ATOMIC_SOC_TERMS ( Hamiltonian_const (:,:)) CALL COMPUTE_ELECTRIC_FIELD ( Hamiltonian_const (:,:)) DO n = 1 , DIM_POSITIVE_K Hamiltonian_const ( n , n ) = Hamiltonian_const ( n , n ) - E_Fermi Hamiltonian_const ( DIM_POSITIVE_K + n , DIM_POSITIVE_K + n ) = Hamiltonian_const ( DIM_POSITIVE_K + n , DIM_POSITIVE_K + n ) + E_Fermi END DO CALL COMPUTE_CONJUGATE_ELEMENTS ( Hamiltonian_const (:,:), DIM ) !This is not needed, since ZHEEV takes only upper triangle DO i = - kx_steps , kx_steps DO j = - ky_steps , ky_steps kx = i * dk1 * ( 2. * PI * 2. / 3. ) ky = j * dk2 * ( 2. * PI * 2. / 3. ) Hamiltonian (:,:) = DCMPLX ( 0. , 0. ) CALL COMPUTE_TBA_TERM ( Hamiltonian (:,:), kx , ky ) CALL COMPUTE_TI1_TI2 ( Hamiltonian (:,:), kx , ky ) !There may be a problem since Ti1,Ti2 coupling is assumed to be equal Ti2,Ti1 CALL COMPUTE_H_PI ( Hamiltonian (:,:), kx , ky ) !There may be a problem since Ti1,Ti2 coupling is assumed to be equal Ti2,Ti1 CALL COMPUTE_H_SIGMA ( Hamiltonian (:,:), kx , ky ) !There may be a problem since Ti1,Ti2 coupling is assumed to be equal Ti2,Ti1 CALL COMPUTE_HUBBARD ( Hamiltonian (:,:), Charge_dens (:)) CALL COMPUTE_SC ( Hamiltonian (:,:), kx , ky , Gamma_SC (:,:,:,:)) CALL COMPUTE_CONJUGATE_ELEMENTS ( Hamiltonian (:,:), DIM ) !This is not needed, since ZHEEV takes only upper triangle Hamiltonian (:,:) = Hamiltonian_const (:,:) + Hamiltonian (:,:) !Should by multiplied by 0.5 if in Nambu space !CALL DIAGONALIZE_GENERALIZED(Hamiltonian(:DIM_POSITIVE_K,:DIM_POSITIVE_K), Energies(i,j,:), U_transformation(:,:), DIM_POSITIVE_K) !Probability(i,j,:,:) = ABS(U_transformation)**2 CALL DIAGONALIZE_HERMITIAN ( Hamiltonian (: DIM_POSITIVE_K , : DIM_POSITIVE_K ), Energies ( i , j ,:), DIM_POSITIVE_K ) Probability ( i , j ,:,:) = ABS ( Hamiltonian (: DIM_POSITIVE_K ,: DIM_POSITIVE_K )) ** 2 END DO END DO OPEN ( unit = 9 , FILE = \"./OutputData/\" // filename , FORM = \"FORMATTED\" , ACTION = \"WRITE\" ) WRITE ( 9 , '(A)' ) \"#N kx[1/a] ky[1/a] Energy[meV] P(yz) P(zx) P(xy) P(lat1) P(lat2) P(s_up) P(s_down)\" DO l = 1 , DIM_POSITIVE_K DO i = - kx_steps , kx_steps DO j = - ky_steps , ky_steps kx = i * dk1 * ( 2. * PI * 2. / 3. ) ky = j * dk2 * ( 2. * PI * 2. / 3. ) !Calculate specific contributions !Distinguishing orbital contributions yz_contribution = 0. zx_contribution = 0. xy_contribution = 0. DO n = 1 , DIM_POSITIVE_K , 3 yz_contribution = yz_contribution + Probability ( i , j , n , l ) zx_contribution = zx_contribution + Probability ( i , j , n + 1 , l ) xy_contribution = xy_contribution + Probability ( i , j , n + 2 , l ) END DO !Distinguishing lattice contributions lat1_contribution = 0. lat2_contribution = 0. DO n = 1 , 3 DO m = 0 , 1 lat1_contribution = lat1_contribution + Probability ( i , j , m * TBA_DIM + n , l ) lat2_contribution = lat2_contribution + Probability ( i , j , m * TBA_DIM + n + 3 , l ) END DO END DO !Distinguishing spin contributions spin_up_contribution = 0. spin_down_contribution = 0. DO n = 1 , TBA_DIM spin_up_contribution = spin_up_contribution + Probability ( i , j , n , l ) spin_down_contribution = spin_down_contribution + Probability ( i , j , TBA_DIM + n , l ) END DO WRITE ( 9 , output_format ) l , kx , ky , Energies ( i , j , l ) / meV2au , & & yz_contribution , zx_contribution , xy_contribution , & & lat1_contribution , lat2_contribution , & & spin_up_contribution , spin_down_contribution END DO END DO WRITE ( 9 , * ) WRITE ( 9 , * ) END DO CLOSE ( 9 ) DEALLOCATE ( Hamiltonian ) DEALLOCATE ( Hamiltonian_const ) DEALLOCATE ( U_transformation ) DEALLOCATE ( Probability ) DEALLOCATE ( Energies ) DEALLOCATE ( Gamma_SC ) DEALLOCATE ( Charge_dens ) END SUBROUTINE CALCULATE_DISPERSION SUBROUTINE CALCULATE_CHERN_PARAMS ( Nk1 , Nk2 , HamDim ) !! Calculates Chern Params, based on https://arxiv.org/abs/cond-mat/0503172 INTEGER * 4 , INTENT ( IN ) :: Nk1 !! Number of divisions along k1 INTEGER * 4 , INTENT ( IN ) :: Nk2 !! Number of divisions along k2 INTEGER * 4 , INTENT ( IN ) :: HamDim !! DImension of the hamiltonian to be diagonalized (e.g. 4 for simple hellical, 24 for LAO-STO) COMPLEX * 16 , ALLOCATABLE :: Psi (:,:,:,:) COMPLEX * 16 :: U1_chern ( HamDim / 2 , HamDim / 2 ), U2_chern ( HamDim / 2 , HamDim / 2 ), U3_chern ( HamDim / 2 , HamDim / 2 ), U4_chern ( HamDim / 2 , HamDim / 2 ) INTEGER * 4 :: i , j , a , b , m , n REAL * 8 :: potChem REAL * 8 :: Bfield ( 3 ) COMPLEX * 16 :: links COMPLEX * 16 :: f_12 , det1 , det2 , det3 , det4 ALLOCATE ( Psi ( - Nk1 / 2 : Nk1 / 2 , 2 , HamDim , HamDim )) i = 0 j = 0 a = 0 b = 0 n = 0 m = 0 potChem = 0 * meV2au Bfield = ( / 0.0 * T2au , 0.0 * T2au , 5.0 * T2au / ) PRINT * , \"Entered chern params\" PRINT * , \"Ham dim \" , HamDim PRINT * , \"HamDim/2\" , HamDim / 2 PRINT * , \"Nk1/2\" , Nk1 / 2 f_12 = DCMPLX ( 0. , 0. ) !Calculate Chern numbers DO j = - Nk2 / 2 , Nk2 / 2 - 1 !This is for memory optimization. I dont have to keep all values of Psi over Brillouin Zone. !Instead I need values for current row and one row above: ! j = 0 ! ******************************** ! ******************************** ! ******************************** ! ******************************** ! ******************************** ! ******************************** ! ******************************** <- this too ! ******************************** <- this I need !In next iteration I can forget about bottom row, the second one becomes the lower one ! and I have to calculate one above ! j = 1 ! ******************************** ! ******************************** ! ******************************** ! ******************************** ! ******************************** ! ******************************** <- this has to be calculated, Psi (:,2,:,:) ! ******************************** <- this becomes Psi(:,1,:,:) ! ******************************** <- this I can forget !It could be improved to keep Nk1 + 1 values, but for now I hope it is not necessary IF ( j . EQ . 0 ) THEN DO n = - Nk1 / 2 , Nk1 / 2 CALL LAO_STO_CHERN_ENERGIES ( Nk1 , Nk2 , n , j , './' , Psi ( n , 1 , :, :)) !First row CALL LAO_STO_CHERN_ENERGIES ( Nk1 , Nk2 , n , j + 1 , './' , Psi ( n , 2 , :, :)) !Second row !CALL HELLICAL_TEST_CHERN(potChem, Bfield, Nk1, Nk2, n , j, Psi(n,1,:,:)) !CALL HELLICAL_TEST_CHERN(potChem, Bfield, Nk1, Nk2, n , j + 1, Psi(n,2,:,:)) END DO ELSE Psi (:, 1 ,:,:) = Psi (:, 2 ,:,:) DO n = - Nk1 / 2 , Nk1 / 2 CALL LAO_STO_CHERN_ENERGIES ( Nk1 , Nk2 , n , j + 1 , './' , Psi ( n , 2 ,:,:)) !Next row !CALL HELLICAL_TEST_CHERN(potChem, Bfield, Nk1, Nk2, n , j+1, Psi(n,2,:,:)) !Next row END DO END IF DO i = - Nk1 / 2 , Nk1 / 2 - 1 !PRINT*, i, j !Calculate U matrices for chern numbers U1_chern = DCMPLX ( 0.0 , 0. ) U2_chern = DCMPLX ( 0.0 , 0. ) U3_chern = DCMPLX ( 0.0 , 0. ) U4_chern = DCMPLX ( 0.0 , 0. ) DO a = 1 , HamDim / 2 DO b = 1 , HamDim / 2 U1_chern ( a , b ) = SUM ( CONJG ( Psi ( i , 1 ,:, a )) * Psi ( i + 1 , 1 ,:, b )) U2_chern ( a , b ) = SUM ( CONJG ( Psi ( i + 1 , 1 ,:, a )) * Psi ( i + 1 , 2 ,:, b )) U3_chern ( a , b ) = SUM ( CONJG ( Psi ( i + 1 , 2 ,:, a )) * Psi ( i , 2 ,:, b )) U4_chern ( a , b ) = SUM ( CONJG ( Psi ( i , 2 ,:, a )) * Psi ( i , 1 ,:, b )) END DO END DO det1 = det ( U1_chern (:, :), HamDim / 2 ) IF ( det1 . ne . 0. ) THEN det1 = det1 / ABS ( det1 ) END IF det2 = det ( U2_chern (:, :), HamDim / 2 ) IF ( det2 . ne . 0. ) THEN det2 = det2 / ABS ( det2 ) END IF det3 = det ( U3_chern (:, :), HamDim / 2 ) IF ( det3 . ne . 0. ) THEN det3 = det3 / ABS ( det3 ) END IF det4 = det ( U4_chern (:, :), HamDim / 2 ) IF ( det4 . ne . 0. ) THEN det4 = det4 / ABS ( det4 ) END IF links = det1 * det2 * det3 * det4 f_12 = f_12 + ATAN ( AIMAG ( links ), REAL ( links )) END DO END DO PRINT * , \"Chern number is \" , f_12 / ( 2 * PI ) DEALLOCATE ( Psi ) END SUBROUTINE CALCULATE_CHERN_PARAMS SUBROUTINE HELLICAL_TEST_CHERN ( potChem , B , Nk1 , Nk2 , i , j , U_transformation ) INTEGER * 4 , PARAMETER :: HamDim = 4 REAL * 8 , PARAMETER :: g = 5.0d0 REAL * 8 , PARAMETER :: tHop = 200 * meV2au REAL * 8 , PARAMETER :: alphaSOC = 100 * meV2au REAL * 8 , PARAMETER :: gammaSC = DCMPLX ( 0.5 * meV2au , 0.0d0 ) REAL * 8 , PARAMETER :: muB = 0.5d0 REAL * 8 , INTENT ( IN ) :: potChem REAL * 8 , INTENT ( IN ) :: B ( 3 ) ![Bx, By, Bz] INTEGER * 4 , INTENT ( IN ) :: Nk1 , Nk2 , i , j COMPLEX * 16 , INTENT ( INOUT ) :: U_transformation ( HamDim , HamDim ) REAL * 8 :: Energies ( HamDim ) REAL * 8 :: dkx , dky REAL * 8 :: kx , ky INTEGER * 4 :: m , n COMPLEX * 16 :: Hamiltonian ( HamDim , HamDim ) dkx = 2.0d0 * PI / Nk1 dky = 2.0d0 * PI / Nk2 Energies (:) = 0.0d0 U_transformation (:,:) = DCMPLX ( 0.0d0 , 0.0d0 ) Hamiltonian (:,:) = 0.0d0 !Calculate all points in Brillouin zone kx = i * dkx ky = j * dky !Diagonal terms !Electrons H(k) Hamiltonian ( 1 , 1 ) = 2.0 * tHop * ( 1. - DCOS ( kx )) + 2.0 * tHop * ( 1 - DCOS ( ky )) - potChem + 0.5 * muB * g * B ( 3 ) Hamiltonian ( 2 , 2 ) = 2.0 * tHop * ( 1. - DCOS ( kx )) + 2.0 * tHop * ( 1 - DCOS ( ky )) - potChem - 0.5 * muB * g * B ( 3 ) !Holes -H*(-k) Hamiltonian ( 3 , 3 ) = - ( 2.0 * tHop * ( 1. - DCOS ( - kx )) + 2.0 * tHop * ( 1 - DCOS ( - ky )) - potChem + 0.5 * muB * g * B ( 3 )) Hamiltonian ( 4 , 4 ) = - ( 2.0 * tHop * ( 1. - DCOS ( - kx )) + 2.0 * tHop * ( 1 - DCOS ( - ky )) - potChem - 0.5 * muB * g * B ( 3 )) !Spin-orbit coupling Hamiltonian ( 1 , 2 ) = 0.5 * mub * g * ( B ( 1 ) - imag * B ( 2 )) + alphaSOC * ( DSIN ( kx ) + imag * DSIN ( ky )) Hamiltonian ( 3 , 4 ) = - ( 0.5 * mub * g * ( B ( 1 ) + imag * B ( 2 )) + alphaSOC * ( DSIN ( - kx ) - imag * DSIN ( - ky ))) !Superconductivity Hamiltonian ( 1 , 4 ) = gammaSC Hamiltonian ( 2 , 3 ) = - gammaSC Hamiltonian (:,:) = 0.5 * Hamiltonian (:,:) CALL COMPUTE_CONJUGATE_ELEMENTS ( Hamiltonian , HamDim ) CALL DIAGONALIZE_GENERALIZED ( Hamiltonian (:,:), Energies (:), U_transformation (:,:), HamDim ) CALL SORT_ENERGIES_AND_WAVEFUNCTIONS ( Energies (:), U_transformation (:,:), HamDim ) END SUBROUTINE HELLICAL_TEST_CHERN SUBROUTINE LAO_STO_CHERN_ENERGIES ( Nk1 , Nk2 , i , j , run_dir , U_transformation ) !! This subroutine calculates energies and wavefunctions of LAO-STO in [111] direction. !! Returns sorted wavefunctions in (i,j) point of the Brillouin zone. INTEGER * 4 , INTENT ( IN ) :: Nk1 !! Number of divisions of Brillouin zone in direction k1. INTEGER * 4 , INTENT ( IN ) :: Nk2 !! Number of divisions of Brillouin zone in direction k2. INTEGER * 4 , INTENT ( IN ) :: i !! Curent point k1_i in the Brillouin zone INTEGER * 4 , INTENT ( IN ) :: j !! Curent point k2_j in the Brillouin zone CHARACTER ( LEN =* ), INTENT ( IN ) :: run_dir !! Directory of the run, where input.nml should be placed. !! It contains material information and physical parameter of calculation: !! Fermi energy, temperature etc. COMPLEX * 16 , INTENT ( OUT ) :: U_transformation ( DIM , DIM ) !! Matrix containing eigenvectors stored in consecutive columns. !! On output sorted based on energies from lowest to highest. REAL * 8 :: Energies ( DIM ) !! Eigenvalues of the hamiltonian COMPLEX * 16 :: Hamiltonian ( DIM , DIM ), Hamiltonian_const ( DIM , DIM ) COMPLEX * 16 :: Gamma_SC ( ORBITALS , N_ALL_NEIGHBOURS , 2 , SUBLATTICES ) REAL * 8 :: Charge_dens ( DIM_POSITIVE_K ) REAL * 8 :: k1 , k2 , kx , ky REAL * 8 :: dk1_Chern , dk2_Chern INTEGER * 4 :: n !PRINT*, \"Allocation ended\" dk1_Chern = K1_MAX / Nk1 dk2_Chern = K2_MAX / Nk2 U_transformation = DCMPLX ( 0. , 0. ) Energies = 0. Gamma_SC = 0. Charge_dens = 0. !PRINT*, \"Entered chern energies\" !Get parameters from simulation CALL GET_INPUT ( TRIM ( run_dir ) // \"input.nml\" ) !CHeck if units are correct ! CALL GET_GAMMA_SC(Gamma_SC(:,:,:,:), TRIM(run_dir)//\"OutputData/Gamma_SC_final.dat\") ! CALL GET_CHARGE_DENS(Charge_dens(:), TRIM(run_dir)//\"OutputData/Chargen_dens_final.dat\") Gamma_SC (:,:, 1 ,:) = 10 0.0d0 * meV2au Gamma_SC (:,:, 2 ,:) = - 10 0.0d0 * meV2au !Computing k-independent terms Hamiltonian_const = DCMPLX ( 0. , 0. ) CALL COMPUTE_TRIGONAL_TERMS ( Hamiltonian_const (:,:)) CALL COMPUTE_ATOMIC_SOC_TERMS ( Hamiltonian_const (:,:)) CALL COMPUTE_ELECTRIC_FIELD ( Hamiltonian_const (:,:)) !CALL COMPUTE_ZEEMAN((/0.0d0, 0.0d0, 0.1*T2au/), Hamiltonian_const(:,:)) DO n = 1 , DIM_POSITIVE_K Hamiltonian_const ( n , n ) = Hamiltonian_const ( n , n ) - E_Fermi Hamiltonian_const ( DIM_POSITIVE_K + n , DIM_POSITIVE_K + n ) = Hamiltonian_const ( DIM_POSITIVE_K + n , DIM_POSITIVE_K + n ) + E_Fermi END DO CALL COMPUTE_CONJUGATE_ELEMENTS ( Hamiltonian_const (:,:), DIM ) !This is not needed, since ZHEEV takes only upper triangle !Calculate eigenvalues and eigenvectors to later compute chern numbers k1 = i * dk1_Chern k2 = j * dk2_Chern kx = 2. * PI / ( SQRT ( 3.0d0 )) * k1 ky = - 2. * PI / 3. * k1 + 4. * PI / 3. * k2 Hamiltonian (:,:) = DCMPLX ( 0. , 0. ) CALL COMPUTE_TBA_TERM ( Hamiltonian (:,:), kx , ky ) CALL COMPUTE_TI1_TI2 ( Hamiltonian (:,:), kx , ky ) !There may be a problem since Ti1,Ti2 coupling is assumed to be equal Ti2,Ti1 CALL COMPUTE_H_PI ( Hamiltonian (:,:), kx , ky ) !There may be a problem since Ti1,Ti2 coupling is assumed to be equal Ti2,Ti1 CALL COMPUTE_H_SIGMA ( Hamiltonian (:,:), kx , ky ) !There may be a problem since Ti1,Ti2 coupling is assumed to be equal Ti2,Ti1 CALL COMPUTE_HUBBARD ( Hamiltonian (:,:), Charge_dens (:)) CALL COMPUTE_SC ( Hamiltonian (:,:), kx , ky , Gamma_SC (:,:,:,:)) CALL COMPUTE_CONJUGATE_ELEMENTS ( Hamiltonian (:,:), DIM ) !This is not needed, since ZHEEV takes only upper triangle Hamiltonian (:,:) = 0.5 * ( Hamiltonian_const (:,:) + Hamiltonian (:,:)) !Should by multiplied by 0.5 if in Nambu space CALL DIAGONALIZE_GENERALIZED ( Hamiltonian (:,:), Energies (:), U_transformation (:,:), DIM ) CALL SORT_ENERGIES_AND_WAVEFUNCTIONS ( Energies , U_transformation , DIM ) ! PRINT*, \"ENERGIES FOR \", i, j, k1, k2 ! DO n = 1, DIM !     PRINT*, Energies(n) ! END DO END SUBROUTINE LAO_STO_CHERN_ENERGIES SUBROUTINE SORT_ENERGIES_AND_WAVEFUNCTIONS ( Energies , Psi , HamDim ) INTEGER * 4 , INTENT ( IN ) :: HamDim COMPLEX * 16 , INTENT ( INOUT ) :: Psi ( HamDim , HamDim ) REAL * 8 , INTENT ( INOUT ) :: Energies ( HamDim ) INTEGER * 4 :: i , j REAL * 8 :: tmpEnergy COMPLEX * 16 :: tmpPsi ( HamDim ) DO i = 1 , HamDim DO j = 1 , HamDim - 1 IF ( Energies ( j ) . GT . Energies ( j + 1 )) THEN !Swap energies tmpEnergy = Energies ( j ) Energies ( j ) = Energies ( j + 1 ) Energies ( j + 1 ) = tmpEnergy !Swap wavefunctions tmpPsi (:) = Psi (:, j ) Psi (:, j ) = Psi (:, j + 1 ) Psi (:, j + 1 ) = tmpPsi END IF END DO END DO DO i = 1 , HamDim Psi (:, i ) = Psi (:, i ) / SUM ( ABS ( Psi (:, i )) ** 2 ) END DO ! DO i = 1, HamDim !     !PRINT*, \"Psi(1,i) \", Psi(1,i) !     Psi(:,i) = Psi(:,i) / (Psi(1,i) / ABS(Psi(i,i))) ! END DO END SUBROUTINE SORT_ENERGIES_AND_WAVEFUNCTIONS COMPLEX * 16 FUNCTION det ( matrix , n ) IMPLICIT NONE INTEGER * 4 , INTENT ( IN ) :: n COMPLEX * 16 , INTENT ( IN ) :: matrix ( n , n ) INTEGER * 4 :: IPIV ( n ) INTEGER * 4 :: info , i IPIV (:) = 0.0d0 CALL ZGETRF ( n , n , matrix , n , IPIV , info ) CALL ZLAPMT (. TRUE ., n , n , matrix , n , IPIV ) det = 1.0d0 DO i = 1 , n det = det * matrix ( i , i ) END DO RETURN END FUNCTION det !MAKE THIS A SUBROUTINE !Plot this dispersion ! OPEN(unit = 9, FILE= \"./OutputData/EnergiesHellical.dat\", FORM = \"FORMATTED\", ACTION = \"WRITE\") ! DO n = -Nk1/2, Nk1/2 !     kx = n*dkx !     ky = kx !     ! Hamiltonian(1, 1) = 2.0*tHop*(1. - DCOS(kx)) + 2.0*tHop*(1 - DCOS(ky)) + 0.5*muB*g*B(3) !     ! Hamiltonian(2, 2) = 2.0*tHop*(1. - DCOS(kx)) + 2.0*tHop*(1 - DCOS(ky)) - 0.5*muB*g*B(3) !     ! !Spin-orbit coupling !     ! Hamiltonian(1,2) = 0.5d0*mub*g*(B(1) - imag*B(2)) + alphaSOC*(DSIN(kx) + imag*DSIN(ky)) !     ! CALL COMPUTE_CONJUGATE_ELEMENTS(Hamiltonian(:2, :2), 2) !     ! CALL DIAGONALIZE_GENERALIZED(Hamiltonian(:2, :2), Energies(:2), U_transformation(:2,:2), 2) !     !Diagonal terms !     !Electrons H(k) !     Hamiltonian(1, 1) = 2.0*tHop*(1. - DCOS(kx)) + 2.0*tHop*(1 - DCOS(ky)) - potChem + 0.5*muB*g*B(3) !     Hamiltonian(2, 2) = 2.0*tHop*(1. - DCOS(kx)) + 2.0*tHop*(1 - DCOS(ky)) - potChem - 0.5*muB*g*B(3) !     !Holes -H*(-k) !     Hamiltonian(3, 3) = -(2.0*tHop*(1. - DCOS(-kx)) + 2.0*tHop*(1 - DCOS(-ky)) - potChem + 0.5*muB*g*B(3)) !     Hamiltonian(4, 4) = -(2.0*tHop*(1. - DCOS(-kx)) + 2.0*tHop*(1 - DCOS(-ky)) - potChem - 0.5*muB*g*B(3)) !     !Spin-orbit coupling !     Hamiltonian(1,2) = 0.5*mub*g*(B(1) - imag*B(2)) + alphaSOC*(DSIN(kx) + imag*DSIN(ky)) !     Hamiltonian(3,4) = -(0.5*mub*g*(B(1) + imag*B(2)) + alphaSOC*(DSIN(-kx) - imag*DSIN(-ky))) !     !Superconductivity !     Hamiltonian(1, 4) = gammaSC !     Hamiltonian(2,3) = -gammaSC !     Hamiltonian(:,:) = 0.5 * Hamiltonian(:,:) !     CALL COMPUTE_CONJUGATE_ELEMENTS(Hamiltonian, HamDim) !     CALL DIAGONALIZE_GENERALIZED(Hamiltonian(:,:), Energies(:), U_transformation(:,:), HamDim) !     DO m = 1, HamDim !         WRITE(9,*) kx, Energies(m)/meV2au !     END DO ! END DO ! CLOSE(9) END MODULE mod_postprocessing","tags":"","loc":"sourcefile/mod_postprocessing.f90.html"}]}